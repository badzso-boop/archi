const QUESTION_DATA = [{"question": "1. Mit jelent a számítási modell kifejezés, sorolja fel a jellemzőit!", "frequency": "Gyakoriság: ritka", "answer": "# Kérdések és Válaszok - Számítógép Architektúrák<br><br>Ez a dokumentum a `vizsga/feltoltott_kerdesek.md` alapján készült, strukturált formában.<br><br>## 1. Modul: Számítási Modellek és Alapok<br><br>A szamitasi modell a szamitasi feladat, vegrehajto mechanizmus és a vezérlés közti kapcsolatot irja le. Nem foglalkozik konkrét hardverrel csak az elvekkel<br>Három fő jellemzője:<br><br>- Min hajtjuk végre (adatok, objektumok)<br>- Hogyan képezzük le a feladatot (milyen programozasi paradigmaval irjuk le -> procedurális, deklaratív)<br>- Milyen modon vezereljuk a sorrendet? (vezerles meghajtott, adat meghajtott, igeny meghajtott)"}, {"question": "2. Mi alapján csoportosítjuk a számítási modelleket? Az elsőben milyen modellek vannak?", "frequency": "Gyakoriság: kevésbé ritka", "answer": "- Szamitasi modelljuk szerint<br>  - Szekvenciális -> egy utasítás fut egyszerre<br>  - Párhuzamos -> tobb utasitas fut parhuzamosan egyszerre<br>- Vezérlés meghajtasa szerint<br>  - vezerles meghajtott -> van egy program counter ami lepesrol lepesre vegigmegy mindenen<br>  - adat meghajtott -> streber modell, amint van adat rogton nekilat a munkank<br>  - igeny meghajtott -> csak akkor szamol amikor muszaj a vegeredmenytol szamol visszafele.<br>- Problema leirasa szerint<br>  - Procedurális -> leirjuk a lepeseket hogyan kell megoldani a problemat<br>  - Deklarativ -> csak a vegeredmenyt irjuk le hogy mit varunk el a hatterben o csinalhat barmit"}, {"question": "3. Jellemezze a Neumann adatmodellt!", "frequency": "Gyakoriság: gyakori", "answer": "A neumann modell proceduralis modell aminel leirjuk lepesrol lepesre mit szeretnenk csinalni. Valtozokat dekralalunk majd az ebben levo adatokat manipulaljuk. Egy program counter megy vegig a lepeseken es hajtja oket vegre. Vigyazni kell mert elozmeny erzekeny igy ha ugrunk a-bol b-be es kozben adatot modositunk lehet arra az adatra mashol is hivatkozunk egy a kesobbiekben hibaba futhatunk. Nehezen lehet parhuzamositani hiszen a lepesek egymas utan kovetkeznek.<br><br>Helyesbítés:<br>Az adatok és a programkód közös memoriaban van. Implicit statikus szekvencia -> pc mindig lepesenkent halad elore."}, {"question": "4. Jellemezze az adatfolyam modellt!", "frequency": "Gyakoriság: gyakori", "answer": "Az adatfolyam modell a streber modell neven hiresult el. Itt amint megjelenik az adat amit egy halmazkent tarolunk azonnal nekilat a munkanak. Egy grafkent kell elkepzelni ahol az eleken mozognak az adatok a csomopontokban pedig muveleteket vegzunk el. Egyszeru parhuzamositani mert ket csomoponton az adatok tudnak egyszerre szamolodni. Itt nincs program counter hanem egybol a megvalositasra torekszik.<br><br>Helyesbites<br>Nincs mellekhatas igy ha egy fuggvenyt meghivsz egy atahalmazzal akkor mindig egy kimenetet fogsz kapni. Mivel nincsenek globalis valtozok. Nincsen kozos memoria az adatok tokenkent kozlekednek a fuggvenyek kozott es ezert csak az az adat letezik ami epp a fuggvenynel van."}, {"question": "5. Hasonlítsa össze a Neumann és az adatfolyam modellt a tanult jellemzők alapján!", "frequency": "Gyakoriság: ritka", "answer": "A neumann modellt nehez parhuzamositani mivel lepesenkent megy vegig minden utasitason ezzel szemben az adatfolyam modellt konnyu parhuzamositani hiszen az adatok tokenkent mennek vegig es egyszerre lehet tobb szamitast vegezni egy adathalmazzal. A neumann modell elozmeny erzekeny mert a valtozokat hasznalunk amiket ha nem megfelelo sorrendben hivunk meg megzavarhatjak a szamitast, mig az adatfolyamnal nincs is memoria es valtozok igy nem kell az adatok manipulalasa miatt aggodni."}, {"question": "6. Sorolja fel a processzor szintű logikai és fizikai architektúra elemeit, illetve a rendszerszintű fizikai architektúra elemeit!", "frequency": "Gyakoriság: kevésbé ritka", "answer": "## 2. Modul: Logikai és Fizikai Architektúra<br><br><br>a fizikai architekturanak az elepei ha szamitogep szemszogebol nezzuk akkor van a cpu a buszrendszer az io rendszer ha processzor szinten nezzuk akkor van az alu, megszakitasok, program counter, memoria A fizikai architekturanal az a fontos hogy az alkatreszeket tudjuk mit szeretnenk belerakni ahhoz hogy elerjuk a celunkat a logikai architekturanal azt irjuk le hogy mi mit csinaljon es hogyan teljesen lenyegtelen milyen alkatresszel oldjuk meg csak a lenyeg hogy meg legyen oldva. A szamitogep szinten az OS ellenorzi egy egy feladat megoldasat processzori szinten pedig a programozo felelossege jol megirni a program kodot hogy a gep azt csinalja amit szeretne logikai szinten a processzor es a szamitogep is egy feketedobozkent mukodik<br><br>Javitas:<br>Rendszer szintu fizikai<br><br>- CPU<br>- MEMORIA<br>- IO<br>- BUSZRENDSZER<br><br>Processzor szintu fizikai<br><br>- ALU<br>- Vezerloegyseg<br>- Regiszterek<br>- Belso buszok<br><br>Processzor szintu logikai<br><br>- Adattér<br>- Adatmanipulacios fa<br>- Allapotter<br>- Allapotmuveletek"}, {"question": "7. Mit jelent az adattér kifejezés, milyen 2 részből áll? Hasonlítsa össze ezeket! Mi határozza meg a címtér méretét?", "frequency": "Gyakoriság: kevésbé ritka", "answer": "_Megjegyzés: A címbusz szélessége határozza meg a méretét. A 2 rész a memóriatér és a regisztertér._<br><br>Az adattér az ahol az adatok várakoznak a felhasznalasra. Van a memoriater es a regiszterter.<br>A memoriaterben van<br><br>- virtualis memoria -> lassu, nagy, programozo latja, hattertaron helyezkedik el<br>- fizikai memoria -> pici gyors es kulon lapkan van de ezt a cpu kezeli mit hova rak eppen<br><br>A regiszterterben tobb fajt regiszter van<br><br>- univerzalis regiszter -> a gyakran hasznalt dolgok itt varakoznak ide barmilyen adatot fel lehet venni<br>- egyszeru regiszter -> ez tulajdonkepp egy akkumulator amin egy adatot lehet tarolni<br>- Stack regiszter -> elonye nem kell cimezni es egyszeru utasitas -> gyors, hatranya -> operandusos kiolvasas csak szekvencialisan<br>- Dedikalt regiszter -> csak egy fajta adathoz lehet csak hasznalni<br>- tobbszoros regiszterkeszlet, amikor egy regiszternek a vege vagyis az out bitje egy masik input regiszternek az input bitjevel egy helyen van igy nem kell kontextust valtani tehat sokkal gyorsabb az adatfeldolgozas. Ezeket tobb szinten szoktak csinalni, de altalaban max 8 ilyen fuznek ossze mert az meg pont a hataron van a gazdasagi es felhasznalasi kerdes miatt. Valamint van a cimezheto regiszterter ahol van egy nagy regiszterter es oda lehet cimezni hogy az elso 4 az egyik programnak kell a masodik 4 egy masiknak, nyolvan az in es out regiszterek ertelemszeruen egy helyre mutatnak a gyorsabb adatvaltas vegett.<br><br>Az adatter merete a cimbusz szelessegetol fugg"}, {"question": "8. Hasonlítsa össze a virtuális és fizikai memóriateret!", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Virtuális és a fizikai memória összehasonlítása + itt szokott kelleni a 2 felhasználó számára transzparens rész is a virtuális memóriához._<br><br>A virtualis memoriateret a programozo latja es vegtelennek tunik o ugy latja mintha a sajat elso adata a 0x0000 cimen lenne pedig ez nem igy van. Van egy memory management unit ami adatmozgatas kozben cimezi a virtualis memoriabol a fizikaiba az adatokat. Ez az oda vissza cimzes teljesen transzparens es nem veszi eszre a felhasznalo. Minden programnak sajat virtualis memoriaja van. A fizikai memoriater veges de gyors mert sajat busza van ami a cpuhoz koti. Ez fregmentalt, lyukacsos lehet es veges mert csak annyi van ami eppen a modulon van."}, {"question": "9. Milyen típusai vannak a többszörös regiszterkészletnek? Jellemezze a legfejlettebbet!", "frequency": "Gyakoriság: gyakori", "answer": "A többszöri regiszterkeszletet azert talaltak ki, hogy gyorsitsak a kontextusok kozti valtast es ezt ugy oldjak meg hogy egy egy regiszterkeszletnek az in es out regiszterei ugyan ott vannak igy amikor valtani kell az elso adat rogton ott is van igy nem kell meg kulon beolvasni, hanem lehet vele ugykodni. Az egyik megvalositasi mod hogy fizikailag ugy helyezik el a regisztereket egymas mellett hogy atfedesek legyenek a masik, hogy van egy nagy regiszterkeszlet es ezen belul lehet cimezni. Ez azert jo mert nincs fix meret lehet valaminek csak ketto regiszter kell valaminek meg 5 ilyenkor tudnak egymasra cimezni hogy az elso ketto az egyik utasitase mig a masik 5 egy masik utasitase. Itt is vannak ugyan ugy atfedesek a gyorsabb valtas vegett."}, {"question": "10. Jellemezze a többszörös regiszterkészletet!", "frequency": "Gyakoriság: ritka", "answer": "_Megjegyzés: Inkább az ez előtti kérdés szokott lenni._<br><Hely a válasznak>"}, {"question": "11. Mit jelent az adatmanipulációs fa kifejezés, milyen szintjei vannak?", "frequency": "Gyakoriság: kihalt", "answer": "Adattipusok: leirja hogy milyen adattipusokat ertelmezhetunk<br>Muveletek: Megmutatja hog yaz adott atattipusokon milyen muveletek ertelmezhetok<br>Operandus tipusai: megkulonboztetjuk az operandusokat szamuk es tipusuk szerint<br>CImzesi modok: engedelyezett lepesek<br>Gepi kod: minden architekturan mas"}, {"question": "12. Mit jelent a gépi kódú utasítás, milyen részekből áll?", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Gondolom ez az MK + Címrész dolog akar lenni._<br><br>A gepi kodu utasitas ket reszbol all maga az muveleti kod ami megmondja hogy mit kell csinalni, valamint a cimresz ezek az operandusokat adjak megmondja melyik adat hol talalhato.<br>A gepi kodu utasitasokat fel lehet bontani az operandusok szama szerint:<br>3 operandusos amikor a ket elso operandussal dolgozunk es a harmadikba mentunk,<br>2 operandusos amikor a kettovel csinalunk valamit majd ezt a masodikba mentjuk<br>1 operandusos amikor az accumulatort is hasznalatba vesszuk igy es az operandusunkat hasznaljuk pl Acc = Acc + A<br>0 operandusos amikor az adatok egy stackben vannak mi megadjuk, hogy add o kiveszi a felso kettot osszeadja majd visszairja."}, {"question": "13. Mutassa be az architektúra rajzát! (CPU felépítés rajza)", "frequency": "Gyakoriság: kihalt", "answer": "_Megjegyzés: Elvileg ilyen rajzokat nem kér már. VISZONT! A CPU regiszterei kellenek (MAR, MDR, IR, PC stb.)_<br><br>A cpu legfontosabb regiszterei a kovetkezok:<br>MAR - Memory Address Register, ide irja ki a cpu hogy eppen melyik memoria cimet fogja olvasni<br>MDR - Memory Data Register, ide irja ki a cpu az adatokat amit a memoriabol kiolvasott<br>PC - Program counter, ez mindig a kovetkezo feladat cimere mutat<br>IR - Instruction Register, ez az eppen futo folyamat vagyis az instrukcio<br>DEC - Decoder, ez forditja a feladatot a gep szamara erthetore<br>ALU - ez hajtja vegre a feladatot<br>AC - Accumulator regiszter ez az ALU fog munka regisztere ide jonnek a muveletek eredmenyei<br>CU - COntrol Unit, ez iranyit mindent hogy mi mit csinaljon"}, {"question": "14. Gépi kód levezetése, utasítás lehívás + tárolás bemutatása", "frequency": "Gyakoriság: ritka", "answer": "_Megjegyzés: Van egy ilyen dia, amit elvileg csak BSc-n kér, gyakorlatilag ki tudja. Nem tudom, hogy amikor a \"gépi utasítást\" kéri az ez, vagy a \"gépi kódú utasítás\"._<br><br>ADD m1 m2<br><br>Fetch<br><br>- MAR <- PC<br>- MDR <- [MAR]<br>- IR <- MDR<br>- PC <- PC + 1<br><br>Execution 1<br><br>- DEC <- IR<br>- MAR <- DEC cimresz (m1)<br>- MDR <- [MAR]<br>- AC <- MDR<br><br>Execution 2<br><br>- DEC <- IR<br>- MAR <- DEC cimresz (m2)<br>- MDR <- [MAR]<br>- AC <- ACC + MDR => ALU muvelet<br><br>Store<br><br>- DEC <- IR<br>- MAR <- DEC cimresz (m1)<br>- MDR <- AC<br>- [MAR] <- MDR"}, {"question": "15. 0, 1, 2, 3, 4 operandus mit csinálnak, sorolja fel az előnyeiket illetve hátrányaikat!", "frequency": "Gyakoriság: kevésbé ritka", "answer": "_Megjegyzés: Utasítás típusoknak is lehet őket hívni (4 címes utasítás, 3 címes utasítás stb.)._<br><Hely a válasznak>"}, {"question": "16. Mit jelent az állapottér kifejezés, rajzolja fel a csoportosítás ágrajzát!", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Definíció + ágrajz._<br><br>Olyan programbol lathato es nem lathato tarolokbol all, melyek az adott programra vonatkozo allaptinformaciokat hordozzak.<br><br>A flagek nem adatot, hanem allapotot tarolnak. Specialis utasitasokkal mentheto, beallithato, torolheto.<br>A transzparens allapotter olyan mechanizmusokbol all amelyeket a program nem kezel kozvetlenul, megis hat a vegrehajtasra<br><br>állapottér<br><br>- látható<br>  - PC<br>  - Státusz indíkátorok (flagek)<br>    - condition code<br>    - univerzalis allapotjelzok<br>    - adattipusonkent kotelezo allapotjelzok<br>  - egyéb<br>    - debug<br>    - címzési módok<br>    - indexelés<br>- transzparens<br>  - virtualis memoriakezeles<br>  - veremkezeles<br>  - megszakitaskezeles"}, {"question": "17. Milyen műveletek végezhetőek el flagek és Program Counter esetén?", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Általában ez az állapotteres feladattal van egyben._<br><br>A flagnél lehet Beállítani (SET), Lekérni (Check), Mentés/Visszatöltés.<br>A PC-nél lehet inkrementálni, felülírni, menteni -> stackre<br><br>PC<br><br>- Inkrementáls<br>- Dekrementálás<br>- Felülírás<br><br>Flag<br><br>- Save<br>- Set<br>- Reset<br>- Load<br>- Clear"}, {"question": "18. Jellemezze az állapot indikátorokat (flageket)!", "frequency": "Gyakoriság: kihalt", "answer": "_Megjegyzés: Az ez alatt lévő szokott lenni._<br><Hely a válasznak>"}, {"question": "19. Sorolja fel az ALU felépítési elemeit!", "frequency": "Gyakoriság: gyakori", "answer": "## 3. Modul: ALU és Számábrázolás<br><br>_Megjegyzés: Eddig rajz is kellett (adatutak miatt), sajnos most fogalmam sincs, hogy itt mit kérdez, mert no way, hogy csak 4 dolgot kell felsorolni._<br><br>- Regiszterek<br>  - Dedikált regiszter, egyszeru regiszter, stack regiszter, többszörös regiszter, univerzális regiszter<br>- Adatutak<br>  - ez koti ossze a cpu-t a regiszterekkel, de fontos ez nem adatbusz. Itt nincs cimzes csak adatkuldes. Egyszerre csak egy adat folyik rajta.<br>- Kapcsolópontok<br>  - ezzel tudja iranyitani az alu, hogy az adatok eppen merre menjenek ezek tranzisztorok<br>- Szűkebb értelembe vett ALU<br>  - ez maga a szamito egyseg ami elvegzi a muveleteket"}, {"question": "20. Mit jelent az adatút kifejezés? Rajzolja fel a két utas csatolási módot, és magyarázza meg mi mit jelent?", "frequency": "Gyakoriság: kihalt", "answer": "_Megjegyzés: Eddig elég sokszor volt (gyakori), főleg az előző kérdéssel együtt. Mostmár viszont szinte teljesen ki került a diákból és azt mondta, nem is fogja kérni._<br><br>Az adatút ami összeköti a CPUn belul a dolgokat, a regisztereket alut pc-t. Mindent. Ez egy nagy vezetekrendszer amin egyszerre csak egy adat mehet az egyik iranyba. Nem kell cimezni csak elkuldeni a megfelelo vezeteken az adatot.<br><br>Két utas csatolási mód amikor van egy bemenet (Load / Enable)<br>Ez vezérli a bemenetet, csak akkor irodik be az adat a regiszterbe, ha a vezerlojel aktiv<br>A kimenet harom allapotu<br>0,1 valamint a zart. Ha eppen nem ő az aktív regiszter akkor lekapcsolódik a sínről a zárt részével"}, {"question": "21. Rajzolja fel az 1 bites félösszeadót, mutassa be a működését, előnyeit, hátrányait!", "frequency": "Gyakoriság: ritka", "answer": "_Megjegyzés: Félösszeadót kérheti, gyakorlatban nagyon ritkán van csak._<br><br>Az egybites félösszeadónál van két bemenet, majd ebből lesz egy kimenet valamint egy carry kimenet. Az igazságtáblája egyszerű. A bekötése is egyszerű, kell egy xor amibe az a és b van bekötve ez adja az S-t valamint egy and amibe ugyan ugy az a es b van bekotve ez adja a carryt.<br><br>Előnye: egyszerű és gyors, hátránya, hogy nem tud mit kezdeni az elozo helyiertekrol jovo atvitellel, tehat nem tudja a carry int feldolgozni.<br><br>A|B|S|C<br>0|0|0|0<br>1|0|1|0<br>0|1|1|0<br>1|1|1|1"}, {"question": "22. Rajzolja fel az 1 bites teljes összeadót, mutassa be a működését, előnyeit, hátrányait!", "frequency": "Gyakoriság: gyakori", "answer": "Az egybites teljes összeadó tudja kezelni az elozo helyiertekrol jovo carryt illetve a vegeredmenyt is ki tudja adni az uj carryvel. Az igazságtáblája bonyolultabb. Kb meg is tudtam csinalni :D. A kapcsolása a háttérben: A és B egy xor kapuba, ennek a kimenete és a Cin is egy xor kapuba es ebbol megkapjuk az S-t. Majd az A, B, Cin 3 and kapuba mindegyik mindegyikkel össze van kötve és ezeknek a kimenete egy or kapuba, ez adja meg a Cout-ot.A hátránya, hogy bonyolultabb és több alkatrész kell hozzá.<br><br>A|B|Cin|S|Cout<br>0|0|0|0|0<br>1|0|0|1|0<br>0|1|0|1|0<br>1|1|0|0|1<br>1|1|1|1|1<br>0|0|1|1|0<br>0|1|1|0|1<br>1|0|1|0|1"}, {"question": "23. Rajzolja fel az N-bites soros összeadót, mutassa be a működését, előnyeit, hátrányait!", "frequency": "Gyakoriság: gyakori", "answer": "Az N bites soros összeadónál van kettő léptető ami a biteket lépteti A-nál és B-nél is, valamint van egy tároló ami a carry-ket vezeti vissza, ha keletkezik. Rajzolni itt nem tudok a markdown fajlba de kepzeld ide :D. ELőnye, hogy már komplexebb számokat is össze tud adni, viszont a hátránya, hogy minél nagyobb a szám annál tovább tart. Főleg ha sok a carry is. Mert egy összeadás egy órajel idejéig tart.<br>Egyetlen teljes összeadó csinálja az összeadásokat. Az idő, hogy összeadja pontosan annyi mint a bitek száma amit összead."}, {"question": "24. Rajzolja fel az N-bites párhuzamos összeadót, mutassa be a működését, előnyeit, hátrányait!", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Szokta a \"ripple carry adder\" kifejezést is használni._<br><br>Az n bites párhuzamos összeadónál a bemenetet fel tudják bontani több teljes összeadóra, így ezek tudnak párhuzamosan számolni. A carryt is bekötik és egymásnak tovább is adják. Akkor van gond ha sok carry keletkezik, hiszen akkor visszavált szinte a soros összeadó sebességére, mivel meg kell várnia az utolsónak is mire a carry odaér hozzá. Előny: Tud gyorsabb lenni mint a soros, viszont hátrány, ha sok a carry akkor szinte azonos sebessége van a sorossal."}, {"question": "25. Rajzolja fel a módosított teljes összeadót, mutassa be a működését, előnyeit, hátrányait! Mit jelent a \"P\" és \"G\", hogyan állnak elő?", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Itt a CLA-ra gondol a költő, de előfordult már, hogy csak a \"módosított összeadó\" részét kérte, de végül is az a lényeg. Azt is mondta, hogy le kell vezetni a C0-ig, de csak addig._<br><br>A modositott teljes osszeado azert gyorsabb mert van egy olyan reszegysege ami ki tudja szamolni elore a carryket igy lehet gyorsitani a szamitast. Előnye: hogy kevesebb ido alatt tud kiszamolni egy egy muveletet hatranya, viszont hogy bonyolult es sok plusz aramkorre van szuksege.<br><br>Erre nem emlekszek most nezem ki<br>P = A + B<br>G = AB<br>Cout = BCin + ACin + AB => AB + (A+B)Cin<br><br>Cout = G + PCin<br>C0 = G0 + P0Cin"}, {"question": "26. Hogyan gyorsítható a fixpontos szorzás, mutassa be ezeket! (Bitcsoporttal való szorzás, Booth-algoritmus)", "frequency": "Gyakoriság: gyakori", "answer": "Bitcsoportos szorzassal gyorsithato a szorzas, mert a szorzasi lepeseket a felere lehet csokkenteni pl egy 32 bites szorzast meg lehet oldani 16 ciklusbol. 3 bitet vizsgalunk egyszerre az elozo 1-t valamint 2t a mostaniakbol i + 1, i, i - 1 az i - 1 azert kell mert meg tudjuk vizsgalni hogy az elozobol maradt-e valami maradek vagy atvitel.<br><br>Booth algoritmus, amikor sok egyes van egy helyen akkor lehet azt csinalni, hogy felkerekitunk a legkozelebbi egesz szamhoz es kivonunk belole annyit, hogy visszakapjuk azt a szamot amit akarunk.<br>pl: 62-vel szeretnenk szorozni, akkor szorzunk 64-el majd kivonunk belole kettot igy a sok szorzas meg eltolas helyett eleg egy szorzas illetve egy negalttal valo osszeadas."}, {"question": "27. Hogyan néz ki a lebegőpontos számok értelmezési tartománya, rajzolja fel az ÉT számegyenesét!", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Általában másik kérdésekkel együtt van._<br><br>A fixpontos szamok abrazolasa 16 bit eseten -32768;+32767 ig van ami eleg kicsi tartomany es a pontossaga sem tul jo.<br><br>Ertelmezesi tartomany:<br><br>```<br>Karakterisztika bitek szama | legnagyobb ertek | ertelmezesi tartomany<br>1                           | 1 = 1            |  2 ^ +- 1<br>2                           | 11 = 3           |  2 ^ +- 3<br>3                           | 111 = 7          |  2 ^ +- 7<br>4                           | 1111 = 15        |  2 ^ +- 15 (=FX16 32768)<br>```<br><br>Tizes szamrendszer alapjan pontossaga<br><br>```<br>felhasznalhato regio                 alulcsordulasi regio   felhasznalhato regio      tulcsordulasi regio<br>|"}, {"question": "28. Hogyan kezelhető a túlcsordulás, illetve alulcsordulás?", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Általában a számegyeneses kérdéssel együtt van._<br><br>Ha tulcsordulas van akkor vagy a pozitiv vegtelent jeleniti meg a rendszer vagy a legnagyobb megjelenitheto szamot jeleniti meg<br>Ha alulcsordulas van akkor kijelzi es konvergal 0-ra vagy a denormalizalt szamot jelzi ki"}, {"question": "29. Jellemezze az örző bitet és rejtett bitet, hogyan őrizhető meg velük a pontosság?", "frequency": "Gyakoriság: gyakori", "answer": "A rejtett bit egyszeru, mivel normalizalasnal mindig 1-essel kezdodik a szam ezert azt az elso bitet ugymond elhagyhatjuk (valojaban elrakjuk a rejtett bitbe) es majd amikor ki kell irni a memoriaba akkor onnan beolvassuk.<br><br>Az orzo bit arra hivatott, hogy van par plusz bit a szamok vegenel igy ha kerekites vagy valami miatt le kene vagni bitet a vegerol akkor azt oda menjtuk ki es amikor normalizalni kell vagy menteni akkor meg onnan olvasunk be biteket igy megmaradhat a nagy pontossag"}, {"question": "30. Mi jellemzi a lebegőpontos számok kódolását?", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Általában másik kérdésekkel együtt van._<br><br>Mantissza kodolasa -> kettes komplemens<br>Karakterisztika kodolasa -> tobbletes kodolassal<br><br>Mert a karakterisztika eseten a tobbletes kod kialakitasa gyorsabb, de a mantisszanal azert nem hasznaljok mert csak alap muveletet lehet elvegezni plus minus"}, {"question": "31. Jellemezze az IEEE lebegőpontos szabványt, milyen részei vannak?", "frequency": "Gyakoriság: gyakori", "answer": "Ez a szabvany megadja hogy kulonbozo CPU-k kozott a szamitas egyseges maradjon. A szabvanynak valo megfeleles hogy a harver es a softver is kielegitse a kovetelmenyeket. Pontossag:<br>Egyszeres 32 bit -> gyors, keves hely, pontatlan<br>Kétszeres 64 bit -> lassabb, cserebe nagyon pontos<br>Bővített 80bit  <br>Négyszeres 128 bit -> ultra magas pontosság, tudományos körökben alkalmazott<br><br>Tárolás<br><br>Egyszeres<br>1 elojel bit, 8 karakterisztika bit, 23 mantissza bit<br>Kétszeres<br>1 elojel but, 11 karakterisztika bit, 52 mantissza bit<br><br>Kerekitesek:<br>Legközelebbre valo kerekites (nem tudjuk melyik iranyba)<br>0hoz valo kerekites (eldobjuk az orzo biteket)<br>Minusz vegtelenhez valo kerekites<br>Plusz vegtelenhez valo kerekites<br><br>Kivételkezelés<br>Ha alul vagy tulcsordulas van, 00val osztunk stb akkor kivetelek kepezodnek"}, {"question": "32. Hogyan történik a műveletvégzés lebegőpontos számok esetében?", "frequency": "Gyakoriság: kihalt", "answer": "**33. Rajzolja fel és mutassa be a lebegőpontos műveletvégzőt!**<br>_(Gyakoriság: gyakori)_<br>_Megjegyzés: Így is szerepelhet a táblázatban: DF ábra, dedikált lebegőpontos műveletvégző. Fontos megemlíteni a párhuzamos műveletvégzést._<br><br>Parhuzamosan vegezheto a mantissza es a karakterisztikanak a szamolasa. AxB -> ma x mb; ka + kb<br><br>```<br>   Vezerlojel<br>       |<br>     Vezerlo<br>  |         |<br>Mantissza  Karakterisztika<br>egyseg          egyseg<br>  |               |"}, {"question": "34. Rajzolja fel a BCD összeadőt, mutassa be a működését, előnyeit, hátrányait!", "frequency": "Gyakoriság: kihalt", "answer": "_Megjegyzés: Elvileg ez már nem tananyag F tanterven, azelőtt elég gyakran volt._<br><Hely a válasznak>"}, {"question": "35. Hasonlítsa össze az FX, az FP és a BCD számábrázolást!", "frequency": "Gyakoriság: kihalt", "answer": "<Hely a válasznak>"}, {"question": "36. Jellemezze a huzalozott áramköri vezérlést!", "frequency": "Gyakoriság: kihalt", "answer": "A huzalozott vezerloegysegek gyorsabbak mivel minden egy alaplapon van elektronikabol osszerakva viszont cserebe nagyon nehezen modosithato es rendkivul bonyolult, ezzel szemben a mikroporgramozottnal van egy egyszerubb vezerlo egyseg majd ebbe programoznak valami logikat. Ez olcsobb kevesbe bonyolultabb es az algoritmus konnyebben modosithato, de cserebe eleg lassu a masikhoz kepest."}, {"question": "37. Jellemezze a mikroprogramozott vezérlést!", "frequency": "Gyakoriság: kihalt", "answer": "A huzalozott vezerloegysegek gyorsabbak mivel minden egy alaplapon van elektronikabol osszerakva viszont cserebe nagyon nehezen modosithato es rendkivul bonyolult, ezzel szemben a mikroporgramozottnal van egy egyszerubb vezerlo egyseg majd ebbe programoznak valami logikat. Ez olcsobb kevesbe bonyolultabb es az algoritmus konnyebben modosithato, de cserebe eleg lassu a masikhoz kepest."}, {"question": "38. Hogyan lehet csoportosítani a memóriákat?", "frequency": "Gyakoriság: ritka", "answer": "## 4. Modul: Memóriák<br><br>_Megjegyzés: Itt az ágrajzra gondol, gyakorlatban sosem láttam ezt a kérdést. Szóval lehet, hogy kihalt, vagy nem is volt._<br><br>A felvezeto memoriak, nagysagrendekkel gyorsabbak a hattertaraknal, ezert kozvetlen a CPU-t szolgaljak ki.<br><br>1. RAM (Random Access Memory) - Írható, olvashato, nem maradando<br><br>- SRAM - statikus<br>- DRAM - dinamikus<br><br>2. ROM (Read Only Memory) - csak olvashato, maradando<br><br>- BIOS<br>- POST tesztek<br>- Eszközspecifikus adatok (MAC cim)<br><br>3. CMOS - specialis elemrol taplalt memoria<br><br>- BIOS beallitasok es valos idejo ora<br>  - kikapcsolt allapotban is megorzi az adatokat<br>  - nagyon alacsony fogyasztas"}, {"question": "39. Jellemezze a DDR4-et! Milyen újdonságok vannak a DDR3-hoz képest?", "frequency": "Gyakoriság: gyakori", "answer": "- A DDR3-hoz képes csokkent a tapfeszultseg 1.5 V -> 1.2 V: kisebb hotermeles, jobb energiahatekonysag<br>- 8N prefetch eljaras<br>  - alacsonyabb orafekvencia meghajtas -> alacsonyabb energiafogyasztas<br>  - Kulso adatatviteli frekvencia novelheto -> savszelesseg megno<br>  - Nagyobb kesleltetes, mint DDR3 eseten ugyanazon orafrekvencia mellett<br>  - Bankok: 16 csoportositva (4 csoport x 4 bank) => DDR3 8 kulonallo bank chipenkent<br>    - vezerles egyszerre 2-4 bankot valaszthat ki<br>    - idoosztasos multiplexeles elven<br><br>Megbizhatosag javitasa<br><br>- ECC mellett CRC (Cycnlic Redundancy Check)<br>- Chipenkent extra paritas => bitcsoport osszeget vizsgalja (paros vagy paratlan)<br>- ODT: ON-Die Termination es feszultsegszabalyozas => memoriachipbe epitett ellenallas ami elnyeli a visszaverodo jeleket.<br>- Gear Down Mode: Csokkenti a prefetch erteket ha szukseges<br><br>DDR4 288 DIMM pin > DDR3 240 DIMM pin"}, {"question": "40. Ismertesse a DDR4 memóriánál tanult 8n prefetch eljárást!", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Lehet együtt a DDR4-el, de szokott külön is szerepelni._<br><br>A DRAM cellak nem kepesek a kulso adatbusz sebessegevel mukodni. Ezért kell a prefetch algoritmus<br><br>Prefetch lenyege:<br><br>- A memoria belso magja egyszerre tobb bitet olvas ki<br>- Ezek egy belso pufferbe kerulnek<br>- A kulso busz tobb lepesben tovabbitja az adatokat<br><br>Kovetkezmeny:<br><br>- A belso busz szelesebb mint a kulso (2N, 4N, 8N, 16N)<br>- Ez noveli a ciklusban mert kesleltetest, de noveli a saveszelesseget<br><br>A ddr4-ben egyszerre 8 adatot olvas ki a memoriachippekbol es ezt viszi tovabb aprankent a busz."}, {"question": "41. Jellemezze a DDR5-öt! Milyen újdonságai vannak a DDR4-hez képest?", "frequency": "Gyakoriság: gyakori", "answer": "Fo fejlesztesek: savszelesseg, parhuzamositas es megbizhatosag novelese.<br>Tapfeszultseg 1.1 V -> meg alacsonyabb energiafogyasztas<br><br>- 16N prefetch eljaras<br>- Nagyobb savszelesseg: magasabb kulso frekvencia<br>- Nagyobb kesleltetes, mint DDR4 eseten<br>- 32 bank csoportositva (8 csoport x 4 bank)<br>- Modulonkent 2 csatorna (32 bit)<br>- On-Die ECC memoria chipbe integralva -> chip szintu hibajavitas<br>- Operacionkent 64 Byte adat tovabbitasa<br>- Akár 12 NYÁK réteg"}, {"question": "42. Írja fel az SDRAM időzítési paramétereit, jellemezze is ezeket egy-egy mondattal!", "frequency": "Gyakoriság: kevésbé ritka", "answer": "_Megjegyzés: Ez inkább a későbbi vizsgákon szokott előfordulni. Elvileg Bprofosoktól nem kéri, gyakorlatban pedig hiszem, ha látom, mert eddig is kérte._<br><br>- tCL (CAS Latency) - varakozas az oszlopcim kiadasa utan az elso adat megjeleneseig<br>- tRCD (RAS to CAS delay) - sor megnyitasa es az oszlopcim kivalasztasi parancs kozott<br>- tRAS (Row Active Time) - minimalis ido amig egy sor nyitva kell maradjon<br>- tRP (Row Precharge) - varakozasi ido egy sor lezarasa utan uj sor nyitasaig<br>- tRC (Row Cycle Time) - minimalis ido ket azonos bankbeli sor aktivalasa kozott<br><br>Olvasasi ciklus menete:<br><br>1. Bank (sor) megnyitasa<br>2. Oszlopadatok olvasasa a megnyitott sorbol<br>3. Bank lezarasa (precharge)<br>4. Legalabb tRP varakozas ujra nyitas elott"}, {"question": "43. Írja le a DRAM teljes olvasási ciklusának lépéseit!", "frequency": "Gyakoriság: kihalt", "answer": "Olvasasi ciklus menete:<br><br>1. Bank (sor) megnyitasa<br>2. Oszlopadatok olvasasa a megnyitott sorbol<br>3. Bank lezarasa (precharge)<br>4. Legalabb tRP varakozas ujra nyitas elott"}, {"question": "44. Jellemezze a DIMM-et! Mi a Registered, ECC, PLL DIMM?", "frequency": "Gyakoriság: gyakori", "answer": "DIMM -> DUal Inline Memory Module. DRAM chipeket tartalmazo memoria modul, tipikusan 64 bites adatuttal 168-288 erintkezovel.<br><br>Registered DIMM<br><br>- A memoriachip es a memoriavezerlo koze regiszter kerul<br>- Csokkenti az elektromos terhelest a vezerlon<br>- Egy orajelnyi kesleltetest okoz<br>- Nagyobb stabilitas sok modul eseten<br><br>ECC DIMM<br><br>- Extra DRAM chip az ECC/paritas bitekhez<br>- Paritásbit: egybites hiba felismerese, javitani nem tud. Tobszoros hibat sem tudja konzisztensen felfedezni<br>- ECC bit<br>  - Egybites hiba felfedezese es javitasa<br>  - Tobb egymas mellett bithiba felismerese es javitasa<br>  - Kijavitatlan hiba eseten rendszerleallitas es naplozas<br><br>PLL (Phase Locked Loop)<br><br>- Fáziszért hurok: órajel elcsuszas mentesitese<br>- Orajel szinkronizalas<br>- Stabilabb, pontosabb mukodes nagy frekvencian"}, {"question": "45. Csoportosítsa a buszrendszereket, mik vannak bennük?", "frequency": "Gyakoriság: kevésbé ritka", "answer": "## 5. Modul: Buszrendszerek<br><br>_Megjegyzés: Ezt is későbbi vizsgákra szokta rakni._<br><br>Átvitel iránya szerint<br><br>- szimplex -> az adat csak egy irányba tud menni pl CLK, RST<br>- fél duplex -> az adat ket iranyba tud menni, de egyszerre csak az egyikbe<br>- full duplex -> ket irany egy idoben. (PCIe)<br><br>Átvitel jellege szerint<br><br>- Dedikált busz -> minden mindennel kommunikál (Intel QPI)<br>  - előny: gyors, közvetlen kommunikáció<br>  - hátrány: merev, nehezen bővíthető<br>- megosztott -> egy nagy egységes vezetéken kommunikál minden, Buszvezérlő utasításokra van szükség az ütközések elkerülésére<br>  - Előny: olcsó, egyszerű megvalósítás, könnyen bővíthető<br>  - Hátrány: lassu, buszfoglalást kell alkalmazni, hiba több eszközt is befolyásol, vezérlés bonyolult<br>- Átvitt tartalom szerint<br><br>  - címbusz: eszközök és memória címzésére szolgál.<br>  - Adatbusz: Adatok szállítása a CPU és a memória / perifériák között. Sávszélesség nőtt az idők folyamán: 1bit, 2bit, 4bit, 8bit, 16bit, 32bit<br><br>  Soros buszok<br><br>  - elég egy vezetékpár<br>  - biteket bitsorozatonkent lehet atkuldeni (ehhez plusz hardver kell)<br>  - egy gyors soros erparon tobb adat tovabbithato mint tobb lassun<br>  - Nagyobb frekvencian nagy tavolsagra biztosit atvitelt jitter nelkul<br><br>  Parhuzamos buszok<br><br>  - Tobb vezeteket hasznal -> tobb adat atvitel<br>  - Sok vezetek hatranya, hogy komplex, draga, sok helyet foglal<br>  - Viszont hardver vonatkozasban konnyu implementalni<br>  - Magasabb frekvencian jonnek a gondok -> jitter<br><br>  Manapsag csak a cpu es memoria kozott van parhuzamos busz"}, {"question": "46. Hasoníltsa össze a PCI és PCIe busz (soros és párhuzamos) buszokat, sorolja fel az előnyeiket illetve hátrányaikat!", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Szokott lenni a PCIe külön is (PCI NEM lehet külön), volt olyan, hogy 1-1 mondatot kért, hogy miért jó egyes tulajdonsága. Olyan is szokott lenni, hogy \"miért gyorsabb, mint az USB?\"_<br><br>- PCI<br><br>  - párhuzamos, megosztott buszrendszer<br>  - Minden csatlakoztatott eszköz azonos címbuszt, adatbuszt, vezérlővonalat használ<br>  - Közvetlen a CPU által látott címtérből kapnak adatot<br>  - buszfoglalás kell<br>  - egy időben csak egy master végezhet munkát<br>  - Előnyök: közel a CPUhoz, viszonylag olcsó, egyszerű felépítés<br>  - Hátrány: megosztott busz, ütközésveszély, párhuzamos átvitel, sok eszköznél jelentősen lassul<br><br>- PCIe<br>  - soros, pont-pont topologiaju buszrendszer<br>  - Nem megosztott busz: minden eszkoz kulon osszekottetest kap a vezeerlo fele<br>  - kulon kuldes es fogadas<br>  - full duplex mukodes<br>  - egy idoben tobb vegpont parhuzamosan kommunikal<br>  - csomagokba agyazott adatatvitel<br>  - tobbfele szelesseg x1, x4, x8, x16, x32<br>  - Elonyok: Nagy adatatviteli sebesseg, kevesebb erintkezo, full duplex, hot-plug tamogatas<br>  - Osszetett protokoll -> nagy vezerlesi overhead, teljesitmeny cpu-tol fugg, dragabb implementacio mint a PCI"}, {"question": "47. USB 4.0 v2 tulajdonságok, gyorsítási lehetőségek!", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Itt USB-C rajzot is kérhet pinekkel, volt olyan, hogy miért gyors stb. A gyorsítási lehetőség nem tudom mit takar._<br><br>Hagyományos usb-a, usb-b<br><br>- 2 erpart tartalmaz<br>- teljesitmenye max 5W<br><br>USB-C<br><br>- 4 erpart tartalmaz<br>- 24 pines csatlakozo 2x12 erintkezo<br>- teljesitmenye: 15W - 100W<br><br>Csatlakozók<br><br>- GND<br>- RX+, RX- -> nagysebessegu adatfogadasi vezetekpar<br>- TX+, TX- -> nagysebessegu adatkuldesi vezetekpar<br>- Vbusz -> aramellatast biztositja<br>- D+, D- -> USB 2.0 adatatviteli vezetek<br>- CC, SBU -> alternativ vezetekek<br><br>```<br>  GND RX+ RX- Vbusz D- D+ CC Vbusz TX- TX+ GND<br>/"}, {"question": "48. Jellemezze a PAM3-at, PAM4-et!", "frequency": "Gyakoriság: nem volt még", "answer": "_Megjegyzés: Valamiért idén sokszor kiemelte, lehet új kérdés lesz?_<br><br>Adatsuruseg novelesere a jelkodolas egy jo megoldas lehet, nem kuldunk gyorsabban jelet, hanem tobb informacio kerul egyetlen jelalakba<br><br>PAM3 (USB 4 2.0, GDDR7 memoria)<br><br>- 3 amplitudo szint -1, 0, +1, (0, 1, 2)<br>- Tritek: harmas szamrendszer<br>- Kozepso szint stabil referencia<br>- Fizikailag stabilabb<br>- Orajelenkent 1.58 bit atvitel tortenik<br><br>PAM4 (2024 Nvidia GPU)<br><br>- 2bit/szimbolum<br>- nagy bithiba arany miatt nem gyorsabb mint a PAM3<br>- Orajelenkent 2 bit atvitel tortenik"}, {"question": "49. Jellemezze az Intel QPI-t és HT-t!", "frequency": "Gyakoriság: nem volt még", "answer": "_Megjegyzés: Ezt mindig mondta, hogy kell, gyakorlatban csak ZV-n volt eddig._<br><br>HyperTransport rendszerbusz<br><br>- Kétirényu soros/parhuzamos szelessavu, alacsony kesleltetesu kapcsolat<br>- Fo feladata a front side bus kivaltasa<br>- CPU lapkajara van integralva, de nagy savszelessegu IO buszkent is alkalmazzak<br>- Ket fele egyseget tartalmaz<br>  - Alagut: vegen talalhato 2 HT port -> tobb HT egyseget tudunk osszefuzni<br>  - Cave: Ez zarja le a tunnelt lancot<br>- PCI-tol elteroen a HT nem rendelkezik dedikalt IO cimterrel, ehelyett mamoriabol lekepzett IO-val rendelkezik<br><br>QuickPath Interconnect<br><br>- Feladata a front side bus kivaltasa<br>- A QPI-t hasznalo procik is lapkara integralt memoria vezerlokkel es non-uniform memory accessel rendelkeznek<br>- Distributed Shared memory: fizikailag elosztott memogira egyetlen logikailag kozos cimterben<br>- 5 reteges architekturat hasznal (2 vezetek minden egyseg kozott): 1 orajel alatt 20 adatbizet tud atvinni parhuzamosan"}, {"question": "50. Rajzolja fel a blokkos DMA rajzát, és mutassa be a működését!", "frequency": "Gyakoriság: kevésbé ritka", "answer": "## 6. Modul: I/O Rendszer<br><br>_Megjegyzés: Rajzot már nem fog elvileg kérni. Viszont a DMA-nál a blokkos átvitel folyamatát tudni kell. Fontos, hogy ezek NEM a DMA paraméterei._<br><br>A blokkos atvitel lepesei:<br><br>- CPU felparameterezi es elinditja a DMA-t<br>- DMA buszhasznalatot ker (DMA request)<br>- CPU lemond a buszrol (DMA ack)<br>- DMA adatot ker a periferiatol az I/O DR-be (data register)<br>- DMA adatit ír a memoriaba az I/O AR (address register) altal meghatarizitt memoria cimre<br>- DC-- (data counter), cim++ ismetles vagy megszakitas kuldese"}, {"question": "51. Írja fel a DMA paramétereit!", "frequency": "Gyakoriság: kevésbé ritka", "answer": "_Megjegyzés: Nem összetévesztendő a blokkos átvitel folyamatával._<br><br>DMA jellemzok:<br><br>- nagy adatmennyiseg -> blokkos atvitel<br>- csak gyors periferiaknal hasznaljak<br>- CPU nem mozgat adatot<br><br>Feltetelei:<br><br>- Kozvetlen memoria-cimgeneralas<br>- Buszvezerlesi funkciok<br>- DMA vezerlo jelenlete<br><br>Regiszterei:<br><br>- DC - Data counter<br>- I/O cimregiszter - I/O AR<br>- I/O adatregiszter - I/O DR<br>- Belso transzparens regiszterek<br><br>DMA parameterei:<br>A felparameterezest a cpu vegzi, a programozott I/O-n keresztul tortenik<br><br>- Atvitel iranya (R/W)<br>- I/O egyseg cime<br>- Memoria kezdocim (I/O AR)<br>- Adat tipusa (byte, char, string)<br>- Atvivendo egysegek szama (DC)<br>- Atvitel modja (blokkos / cikluslopasos)<br>- DMA csatorna prioritasa<br>- Resztvevo egysegek tipusa (I/O-memoria, memoria-memoria, I/O-I/O)"}, {"question": "52. Sorolja fel a feltétel nélküli adatátvitel előfeltételeit! (I/O rendszer)", "frequency": "Gyakoriság: gyakori", "answer": "Az adatatvitel ellenorzes es visszacsatolas nelkul tortenik<br><br>Elofeltetelei:<br><br>- Preiferianak mindig adatatvitelre alkalmas allapotban kell lennie<br>- Nincs ellenorzes<br>- Semmilyen szinkronizalas nincs a CPU es periferia kozott"}, {"question": "53. Rajzolja fel az I/O felosztását, előnyök hátrányok.", "frequency": "Gyakoriság: kevésbé ritka", "answer": "_Megjegyzés: Ez is ágrajz, nem tudom, hogy ezt mennyire kéri és hogy pontosan mit lehet írni előnyökhöz, hátrányokhoz._<br><br>- I/O rendszer<br><br>  - Programozott I/O ==> elonyok: egyszeru felepites, olcso megvalositas, konnyen programozhato<br>    - cimzes<br>      - kulonallo I/O cimter<br>      - Memoriaban lekepzett I/O<br>    - mukodes<br>      - Lekerdezes I/O<br>      - Megszakitasos I/O<br>  - DMA<br>    - Blokkos<br>    - Cikluslopasos<br>  - I/O csatorna<br>    - Szelektor csatorna<br>    - Multiplexer csatorna<br><br>- Programozott I/O<br>  - elonyok: egyszeru felepites, olcso megvalositas, konnyen programozhato<br>  - hatranyok: lassu, erosen terheli a CPU-t, nagy adatmennyisegnel nem hatekony<br>- DMA<br>  - elonyok: a cpu csak megcimzi es utana foglalkozhat massal a dma dolgozik a hatterben<br>  - hatranyok: dragabb es komplexebb<br>- I/O csatorna<br>  - elonyok: a lassabb periferiakat is tudja kezelni ugy mintha egy dma lenne<br>  - hatranyok: a cpunak az elejen foglalkozni kell vele"}, {"question": "54. Ismertesse az programozott I/O tulajdonságait, adatátviteli módjait! (feltétel nélküli adatátvitel, feltételes adatátvitel: lekérdezéses, megszakításos)", "frequency": "Gyakoriság: új", "answer": "_Megjegyzés: Első felbukkanás: 2025. 12. 16. (2025/26/1 1. vizsga)_<br><br>Olyan adatatviteli modszer ahol a CPU kozvetlenul iranyitja az I/O muveletet. Elinditja, vezeri, figyeli az allapototo es lezarja az adatatvitelt<br><br>Jellemzok:<br><br>- CPU vezerelt adatatvitel<br>- Lekerdezeses vagy megszakitasos vezerles<br>- kozos buszhasznalat a memoria es az IO kozott<br>- Egyszeru hardveres megvalositas<br>- Jelentos cpu idot igenyel<br><br>ELonyok:<br><br>- egyszeru felepites<br>- olcso megvalositas<br>- konnyen programozhato<br><br>Hatranyok<br><br>- lassu, erosen terheli a CPU-t<br>- nagy adatmennyisegnel nem hatekony<br><br>Adatatviteli modok:<br><br>- Feltetel nelkuli adatatvitel<br>  - Az adatatvitel ellenorzes es visszacsatolas nelkul tortenik<br>  - periferianak mindig adatatvitelre kepes allapotban kell lennie<br>  - nincs ellenorzes<br>  - semmilyen szinkronizalas nincs a cpu es a periferia kozott<br>- felteteles adatatvitel<br>  - Lekerdezeses<br>    - A CPU folyamat olvassa az allapot regisztert amig az eszkoz keszen nem all. Beirja a kivansagat az I/O vezerlobe es varja a valaszt.<br>    - Aktivan varakozik, nem ismert varakozasi ido<br>    - Rendkivul pazarlo, lassu periferiahoz kulonosen rossz<br>  - Megszakitasos<br>    - A CPU elinditj az I/O muveletet, majd mas feladatot vegez. A periferia megszakitassal jelez ha kesz<br>    - elony: a CPU kihasznaltsag jobb, gyorsabb mint a lekerdezeses<br>    - hatrany: nagy mennyisegu adat eseten sok megszakitas, meg mindig a CPU kezdemenyezi es vezerli az atvitelt"}, {"question": "55. Milyen típusai vannak az I/O csatornának? Jellemezze ezeket!", "frequency": "Gyakoriság: kihalt", "answer": "_Megjegyzés: Elméletben kérheti a szelektor csatornát és multiplexer csatornát, azok jellemzőit, gyakorlatban sose kérte eddig._<br><br>DMA tovabbfejlesztese lassabb periferiakhoz. A CPU nem parameterez hanem a memoriaban tarolt I/O programot indit el amelyez az I/O csatorna hajt vegre. Nincs felparameterezes, onallo vezerloegyseg<br><br>Szelektor csatorna<br>lassabb periferiak kozul a gyorsabbakhozá<br><br>- egyetlen I/O vonal, amire tobb I/O vezerlo is racsatlakozhat<br>- egyszerre csak 1 aktiv<br>- elony: gyors atvitel<br>- hatrany: nincs parhuzamossag<br><br>Multiplexer csatorna<br>lassu periferiak kozul is a lassabbhoz -> parhuzamos kezeles<br><br>- Byte multiplexer: byteonkenti adatkuldes<br>- Blokk multiplexer: blokkonkenti adatkuldes"}, {"question": "56. Mutassa be az általános megszakítás ábráját!", "frequency": "Gyakoriság: kihalt?", "answer": "## 7. Modul: Megszakítási Rendszer<br><br>_Megjegyzés: Nem nagyon láttam még kérdésben, de lehet volt._<br><br>1. utasítas vegrehajtas<br><br>- erkezett megszakitas?<br>  - Igen<br>    - Elfogadhato?<br>      - Igen<br>        - Analizis<br>        - Allapot mentese<br>        - Megszakitas kiszolgalasa<br>        - Allapot visszatoltese<br>        - Kovetkezo utasitas<br>      - Nem<br>        - Kovetkezo utasitas<br>  - Nem<br>    - kovetkezo utasitas"}, {"question": "57. Mi a megszakítás definíciója, célja?", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Definíció, célok, általában másik kérdésekkel szokott szerepelni._<br><br>Definicioja: A feldolgozas szempontjabol varatlannak tekingheto esemenyek kezelesere szolgalo muvelet<br><br>Celja: Nem csak a reagalas hanem a folyamatosan valtozo korulmenyek kozott az optimalis mukodes biztositasa<br><br>Lényege: Csak akkor foglalja le a CPU figyelmet amikor arra tenyleg szukseg van."}, {"question": "58. Milyen megszakítási okok, források vannak?", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Ez szokott szerepelni az előzővel. Elvileg itt fontos a sorrend (mert prioritási sorrend van)._<br><br>1. Géphibák<br><br>- nem letilthato, legmagasabb prioritas, nem kesleltetheto<br><br>2. I/O források<br><br>- perfieriak jelzik<br><br>3. Kulso forrasok<br><br>- felhasznalo vagy kulso rendszer<br><br>4. Programozasi forrasok<br><br>- szandekos: amikor egy program megszakitast ker<br>- nem szandekos (hibakezeles): mindig valamilyen utasitas vegrehajtasa vagy a vegrehajtas megkiserlese soran alakul ki<br>  1. memoriavedelem megsertese<br>  2. fizikai cim tulcimzese<br>  3. cimzesi eloirasok megsertese<br>  4. aritmetikai hibak"}, {"question": "59. Hogyan lehet csoportosítani a megszakításokat?", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Itt nem kell annyira mélyre menni, ez is szokott szerepelni az előzőkkel._<br><br>- Szinkron vs aszinkron<br>  - szinkron: program mindig ugyan ott jelentkezik megszakitassal<br>  - aszinkron: veletlenszeruen lepnek fel<br>- Utasitasok kozott vagy kozben<br>  - Kozott: Utasitas vegrehajtasanak eredmenyekepp kovetkezik be (overflow)<br>  - Kozben: Utasitas vegrehajtasa alatt, nincs szinkronban a ciklussal (hardverhiba)<br>- Felhasznalo altal kert vs nem kert<br>  - kert: rendszerhivasokk. OS rutinok, BIOS rutinok<br>  - nem kert: overflow, I/O egyseg altal kert, hardverhiba<br>- Megszakitott program folytathato vs nem folytathato<br>  - folytathato: I/O megszakitas<br>  - nem folytathato: hardverhiba<br>- Maszkolhato vs nem maszkolhato:<br>  - maszkolhato: le lehet tiltani, prioritas alapjan nem lep ervenybe<br>  - nem maszkolhato: sulyos hardverhiba"}, {"question": "60. Mikor érvényes a megszakítás?", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: 3 feltétel, szokott szerepelni az előzőkkel._<br><br>- Az aktualis folyamat megszakithato<br>- a megszakitas prioritasa megfelelo<br>- A megszakitas nincs maszkolva"}, {"question": "61. Milyen megszakítási rendszerek vannak?", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Egyszintű, többszintű, többszintű és többvonalú. Kis magyarázat és rajz is szokott kelleni._<br><br>- egyszintu megszakitasi rendszer<br><br>  - nem megszakithato<br>  - uj megszakitas csak a normal allapotba valo visszateres utan kezdodhet<br><br>  ```<br>  megszakitasi szint"}, {"question": "62. Sorolja fel a tranzisztorok fajtáit, melyik mit tud?", "frequency": "Gyakoriság: kevésbé ritka", "answer": "## 8. Modul: Tranzisztorok<br><br>_Megjegyzés: nMosFET, feszített szilícium, HKMG, FinFET, GAAFET, MBCFET. Mindegyikhez 1-1 mondat, illetve mi az előny az előzőhöz képest._<br><br>A trenzisztor egy felvezeto alapu aktiv elem, amelyet digitalis aramkorokben leggyakrabban kapcsolokent hasznalunk.<br><br>- Source (forrás): Az a terulet ahonnan a tolteshordozok elindulnak<br>- Drain (nyelő): Az a terulet ahova a tolteshordozok erkeznek<br>- Gate (kapu): A vezerlo elektroda amely a csatorna vezetokepesseget szabalyozza<br><br>Legfontosabb meretek:<br><br>- Pitch: A tranzisztor teljes szelessege<br>- Gate length<br>  - Elmeleti hossz: A kapu fizikai szelessege a gyartasi terv szerint<br>  - Fizikai hossz: A tenlyeges csatorna hossz a source es a drain kozott.<br><br>Fajták:<br><br>nMOSFET (Metal-Oxide-Semiconductor Field-Effect Transistor)<br><br>- Substrate: p-tipusu szilicium lapka<br>- Source/Drain: erosen doppingolt negativ szigetek<br>- Szigetelo (Oxid): egy vekony szilicium-dioxid<br>- Mukodese<br>  - Kikapcsolt allapot: alaphelyzetben a p-tipusu hordozoban nincs elegendo szabad elektron igy nem folyik aram<br>  - Bekapcsolas: a kapu pozitiv feszultseget kap es ez elektromos teret hoz letre<br>  - Csatorna kialakulasa: Ez a ter eltaszitja a pozitiv lyukakat es oda vonzza az elektronokat a kapu ala.<br><br>Feszített szilícium technologia<br><br>- Megfelelő gyártási eljárással a szilícium atomok kozotti tavolsagot megnovelik<br>- Előnye: np az elektronok és a lyukak mozgékonysága ami 10%-20%-os teljesítmenyjavulast eredmenyez<br>- Hatranya: Tobb lepesbol all a gyartasi folyamat igy az ara is<br><br>HKMG<br>A problema hogy a tranzisztorok zsugorodtak a Sziliciom-oxid is vekony lett => szivargas jott letre<br><br>- Megoldás: lecserélik egy High-k (nagy dielektromos állandójú) anyagra és fémkapura<br>  - Csökkent a bekapcsoláshoz szükséges áram<br>  - Gyorsabban lehet a tranzisztort kapcsolni<br>  - Csökkent a szivargas.<br><br>FinFET<br>Eddig a Source es a Drain kozotti hidat a kapu alatt alakitottak ki. 2D<br><br>A FinFET-nél ez már 3D-s struktura ahol van egy fesu fog amelyet a kapu 3 oldalrol vesz korbe. Igy ha a kapu kinyilik akkor a hid sokkal nagyobb feluleten tud kialakulni.<br><br>Ezt kesobb noveltek, ugy hogy tobb fesufogat is osszekapcsoltak<br><br>A 2. generacios FinFET pedig a fesu magassagaval es a suruseg javitsavala ismet tovabb gyorsult es hatekonyabb lett.<br><br>GAAFET<br>Tobb aramlasi reteg van kis szalagokban. Ezt veszi korbe a gate es igy mikor megengedjuk az aramlast akkor 4 iranybol tud aramolni az elektron. (nanowire)<br><br>MBCFET<br>A lapok szelessege valtoztathato igy mar nem nanowire lesz hanem inkabb nanosheet. Nagyobb aramerosseget es jobb teljesitmenyt lehet elerni ugyan azon a feszultsegen"}, {"question": "63. Rajzolja fel és mutassa be az nMOSFET tranzisztort!", "frequency": "Gyakoriság: gyakori", "answer": "Az nMOSFET tranzisztor áll egy Source és Drainből, amik erősen doppingolt negatív szigetek a p-tipusu substratetol. Es van egy szigetelo oxid ami szilicium oxid es ez a reteg valasztja el a kaput a substratetol<br><br>```<br>             gate<br>        _______________"}, {"question": "64. Rajzolja fel és mutassa be a HKMG tranzisztort!", "frequency": "Gyakoriság: gyakori", "answer": "Ahogy zsugorodtak a tranzisztorok a szilicium-oxid szigetelo mar tul vekony lett igy gyakran szivargas alakult ki. Ezt a reteget lecsereltek egy High (nagy dioelektromos allandoju) anyagra es femkapura<br><br>- Csokkent a bekapcsolashoz szukseges aram<br>- gyorsabban lehet a tranzisztort kapcsolni<br>- gyokkent a szivargas az oxid es a source-drain kozott<br><br>```"}, {"question": "65. Rajzolja fel és mutassa be a 3D FinFET tranzisztort!", "frequency": "Gyakoriság: gyakori", "answer": "FinFET<br>Eddig a Source es a Drain kozotti hidat a kapu alatt alakitottak ki. 2D<br><br>A FinFET-nél ez már 3D-s struktura ahol van egy fesu fog amelyet a kapu 3 oldalrol vesz korbe. Igy ha a kapu kinyilik akkor a hid sokkal nagyobb feluleten tud kialakulni.<br><br>Ezt kesobb noveltek, ugy hogy tobb fesufogat is osszekapcsoltak<br><br>A 2. generacios FinFET pedig a fesu magassagaval es a suruseg javitsavala ismet tovabb gyorsult es hatekonyabb lett.<br><br>3d-be mar nem tudok rajzolni .md fajlba :D"}, {"question": "66. Sorolja fel a cache típusait, és ismertesse ezeket! (aszerint hogy a blokkok hova kerülnek)", "frequency": "Gyakoriság: gyakori", "answer": "## 9. Modul: Cache Memória<br><br>_Megjegyzés: Full associative, direct mapping, N-way associative, mindegyikhez 1-1 mondat, előny, hátrány. Szokott külön lenni az N-way associative (mert az a legjobb)._<br><br>- Full associative<br>  - egy memoriablokk barmely cache sorba kerulhet<br>  - elhelyezes sorat a helyettesitesi strategia hatarozza meg<br>  - kereseskor a cpu a tageket vizsgalja minden sorban egyszerre, mivel az adat barhol lehet<br>  - nagy talalalti arany es rugalmassag<br>  - draga, bonyolult, nagy fogyasztas<br>- direct mapping<br>  - egy memoriablokk csak egy adott cache lineba kerulhet<br>  - egy cache linehoz tobb memoria blokk hozza van rendelve, elofordulhat, hogy gyakran cserelni kell a cache tartalmat<br>  - elony, gyors es olcso<br>  - hatrany, rugalmatlan, alacsonyabb talalati aran<br>- n-way associative<br><br>  - Kompromisszum az elozo ketto kozott<br><br>    - egy blokk N kulonbozo cache lineba kerulhet<br>    - N tipikusan 2, 4, 8, 16<br>    - Kevesebb osszehasonlito aramkor szukseges<br>    - Jo talalati arany es elfogadhato koltseg<br><br>    Pl.: 4 utas eseten egy blokk 4 cache lineba kerulhet -> CPU csoport index alapjan 4 darab cache line-ra tudja szukiteni a keresest igy eleg 4 osszehasonlito aramkor<br><br>- sector mapping cache<br>  - A csoport barhova kerulhet, viszont a blokknak a helye a csoporton belul kotott"}, {"question": "67. Röviden ismertesse a cache-eknél tanult két legfontosabb vezérlő bitet!", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Dirty bit, Valid bit._<br><br>- Dirty bit: jelzi, hogy az adat modosult-e<br>  - az ilyen blokk helyere nem lehet uj adatot betolteni<br>  - elobb a modositott adatokat ki kell irni a memoriaba<br>- Valid bit: jelzi, hogy a cache sor vagy blokk ervenyes-e<br>  - Ha V=1 akkor ervenyes az adat<br>  - Torles utan V=0, ezzel jelzi a CPU-nak, hogy szabadon irhato terulet"}, {"question": "68. Mi az a \"TAG\" és mire való?", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Más kérdésekkel szokott együtt lenni._<br><br>A cache-ben a memoria egyes, egymast koveto rekeszeinek a tartalmat taroljuk. Ezek melle el kell tarolni az adatok memoria cimet is.<br><br>TAG: memoriacim cache-ben tarolt resze<br>A TAG alapjan dontheto el, hogy a keresett adat az adott cache sorban talalhato-e<br><br>A TAG szarmazhat<br><br>- fizikai cimbol (cache az MMU utan)<br>- virtualis cimbol (cache az MMU elott)<br><br>Virtualis TAG hatranya<br><br>- nagyobb TAG meret, mert a virtualis cimter is nagyobb<br>- Virtualzaciobol adodo helyettesitesek kezelese (-> ugyan az a virtualis cim mutathat tobb kulonbozo fizikai cimre attol fuggoen melyik folyamat fut eppen)<br><br>Virtualis TAG elonye: kisebb cache miss kesleltetes<br><br>Cache hit: a keresett adat a cache-ben megtalalhato => gyorsan elerheto<br>Cache miss: a keresett adat nincs a cache-ben => RAM-ból olvas - lassu, az adat betoltodik a regiszterbe es a CACHE-be is."}, {"question": "69. Mi az a \"cache line\", miből épül fel?", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Felsorolás, rajz._<br><br>64 byte-os cache line eseten a felepites:<br><br>- Directory Entry: TAG es egyeb allapotjelzok<br>- Tprot: TAG protection bitek => biztositjak a tag egyezoseget elirasok ellen<br>- Dprot: Data protection bitek => biztositjak az adat egyezoseget elirasok ellen<br>- State: allapot bitek (V bit, D bit)<br>- Data: az adat<br><br>```"}, {"question": "70. Milyen adatszervezési módokat ismer?", "frequency": "Gyakoriság: kevésbé ritka", "answer": "_Megjegyzés: Nem nagyon láttam eddig, de simán kérdezheti._<br><br>- Exclusive cache<br>  - cache szintek nem tartalmazzak egymas adatait<br>  - ugyanaz az adat csak egy szinten jelenhet meg<br>  - tobb CPU vagy mag eseten komplikalt<br>  - Adatok betoltese ketfelekeppen tortenhet:<br>    - Eloszor L3-ba ls ha szukseges akkor onnan L2-be, L1-be<br>    - Eloszor L1-be, majd ami nem fer be L2-be, ami oda se az L3-ba<br>- Inclusive cache<br>  - magasabb szintu cache tartalmazhatja az alacsonyabb szint adatait<br>  - Hatrany: duplikacio es csokken az alacsonyabb szintu cache merete<br>  - Elonye:<br>    - Magasabb szintu cache sora szabadon cserelheto, mert alacsonyabban is megtalalhato az adat<br>    - Tobb mag eseten, masik mag cacheben kell keresni akkor duplikalas miatt eleg az alacsony szintuben<br><br>Megjegyzés: tobb magos CPU eseten L1, L2 gyakran inclusive, L3 nem"}, {"question": "71. Milyen replacement policy-k vannak?", "frequency": "Gyakoriság: kevésbé ritka", "answer": "_Megjegyzés: Ez a FIFO, LIFO, LFU, LRU, ez is inkább más kérdéssel szerepel együtt._<br><br>Állapot: cache tele van<br><br>Fobb tipusok:<br><br>- FIFO: legregebben betoltott blokk<br>- LIFO: legutobb betoltott blokk<br>- LFU: legritkabban hasznalt blokk<br>- LRU: legregebben hasznalt blokk"}, {"question": "72. Mi az a koherencia kezelés, ismertesse a MESI koherencia kezelést!", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Lehet a MOESI is. A többit is fel kell tudni sorolni, csak nem kell részletesen ismertetni._<br><br>Tobb CPU-s vagy tobbmagos rendszerek eseteben figyelni kell arra hogy egyes CPU-k (vagy magok) gyorsitotaraban megegyezo adatok legyenek.<br>Cel, hogy a modositott adat a leheto leggyorsabban bekeruljon az osszes processzor gyorsitotaraba, mielott a tobbi esetletgesen muveletet vegezne rajta<br><br>Adatervenyesites modja:<br><br>- invalidacio: az erintett cache line ervenytelenitese (V bit = 0)<br>- Feluliras: a modositott adat kozvetlen elkuldese a tobbi cachebe<br><br>Cache koherencia protokollok<br><br>- Snoopy -> minden cache figyeli a kozos buszt<br>- Snorf -> snoopy egy variansa<br>- Konyvtar alapu -> kozponti nyilvatartas kezeli mely cache-ek tartalmazzak az adatot<br>- MESI<br>- MOESI<br><br>MESI<br><br>- M - Modified: az adat modosult csak ez a tar valid a tobbi invalid<br>- E - Exclusive: az adat megegyezik a memoriaval, csak ebben a cache-ben van<br>- S - Shared: az adat tobb cache-ben is megtalalhato es egyezik a memoriaval<br>- I - Invalid: a cache line ervenytelen, nem tartalmaz hasznalhato adatot<br><br>MOESI<br><br>(- M - Modified: az adat modosult csak ez a tar valid a tobbi invalid)<br><br>- O - Owned: A modosult es megosztott allapotot helyettesiti. Egyetlen cache tulajdonaban van, ezzel elkerulheto, hogy vissza keljen irni a memoriaba megosztas elott.<br>  Elony: a modositott adat kozvetlenul atadhato egyik cachebol a masikba.<br><br>- E - Exclusive: az adat megegyezik a memoriaval, csak ebben a cache-ben van<br>  (- S - Shared: az adat tobb cache-ben is megtalalhato es egyezik a memoriaval)<br>- I - Invalid: a cache line ervenytelen, nem tartalmaz hasznalhato adatot"}, {"question": "73. Párhuzamosság szintjei (funkcionális), típusai felsorolás, kik/mik törekednek a számítások felgyorsítása érdekében.", "frequency": "Gyakoriság: ritka", "answer": "## 10-11. Modul: Párhuzamosság és Pipeline<br><br>_Megjegyzés: Szerintem ilyen mélyen már nem fogja ezt kérdezni._<br><br>Párhuzamosság típusai<br><br>- Funkcio szerint<br><br>  - Rendelkezesre allo parhuzamossag: Magaban a feladatban vagy a programkodban rejlo elvi lehetoseg, fuggetlen a konkret hardvertol<br>  - Kihasznalhato parhuzamossag: amit az adott architektura a vegrehajtas soran tenylegesen kepes megvalositani<br><br>- Elhelyezkedes szerint<br><br>  - Idobeli parhuzamossag: tobb vegrehajto egyseg mukodik idoben elcsusztatva (futoszallag/pipeline), jellemzeon nem ugyan azon a reszfeladaton<br><br>  ```<br>  -> VE1 -> VE2 -> VE3<br>  ```<br><br>  - Terbeli parhuzamossag: Tobb azonos tipusu vegrehajto egyseg egy idoben ugyan azt a muvelettipust vegzi<br><br>  ```<br>   -> VE1 -><br>   -> VE2 -><br>   -> VE2 -><br>  ```<br><br>- Tipus szerint<br>  - Adatparhuzamossag<br>    - Adatparhuzamos architekturak<br>      - Adat-elemeken parhuzamos vagy futoszallag elvi vegrehajtast teszik lehetovet<br>    - Atalakitas funkcionalis parhuzamossagga<br>      - Adat elemeken vegrehajthato muveletek ciklusok formajaban torteno megfogalmazasa<br>  - Funkcionalis parhuzamossag<br>    - A feladat logikajabol kovetkezo parhuzamossag. Kulonbozo muveletek fuggetlenul vegezhetok<br><br>Funkcionalis programozas szintjei<br><br>- Utasitas szint: Programutasitasok parhuzamos vegrehajtasa<br>- Ciklus szint: Egymast koveto iteraciok parhuzamositasa (fuggosegek akadalyozhatjak)<br>- Eljaras szint: Parhuzamosan vegrehajthato eljarasok formajaban jelenik meg, merteke a feladat jellegetol fugg<br>- Program szint: Egymastol fuggetlen programok parhuzamos futtatasa<br>- Felhasznalo szint: tobb fuggelten felhasznalo egyideju kiszolgalasa<br><br>Parhuzamossagra torekedes:<br><br>- Programozo: Ugy irja meg a kodot hogy parhuzamosithato legyen<br>- Forditoprogram: Elemzi a kodot es megprobalja az utasitasokat atrendezni, vagy optimalizalni a ciklusokat<br>- Operacios rendszer: Menedzseli a szalakat es a folyamatokat, es osztja el oket a CPU magok kozott"}, {"question": "74. Hogyan csoportosítható a párhuzamosság?", "frequency": "Gyakoriság: ritka", "answer": "- Funkcio szerint<br><br>  - Rendelkezesre allo parhuzamossag: Magaban a feladatban vagy a programkodban rejlo elvi lehetoseg, fuggetlen a konkret hardvertol<br>  - Kihasznalhato parhuzamossag: amit az adott architektura a vegrehajtas soran tenylegesen kepes megvalositani<br><br>- Elhelyezkedes szerint<br><br>  - Idobeli parhuzamossag: tobb vegrehajto egyseg mukodik idoben elcsusztatva (futoszallag/pipeline), jellemzeon nem ugyan azon a reszfeladaton<br><br>  ```<br>  -> VE1 -> VE2 -> VE3<br>  ```<br><br>  - Terbeli parhuzamossag: Tobb azonos tipusu vegrehajto egyseg egy idoben ugyan azt a muvelettipust vegzi<br><br>  ```<br>   -> VE1 -><br>   -> VE2 -><br>   -> VE2 -><br>  ```<br><br>- Tipus szerint<br>  - Adatparhuzamossag<br>    - Adatparhuzamos architekturak<br>      - Adat-elemeken parhuzamos vagy futoszallag elvi vegrehajtast teszik lehetovet<br>    - Atalakitas funkcionalis parhuzamossagga<br>      - Adat elemeken vegrehajthato muveletek ciklusok formajaban torteno megfogalmazasa<br>  - Funkcionalis parhuzamossag<br>    - A feladat logikajabol kovetkezo parhuzamossag. Kulonbozo muveletek fuggetlenul vegezhetok"}, {"question": "75. Mi az a rendelkezésre álló párhuzamosság - [Szálak fontosak, gondolom a létrehozás] --> Programozó, OS, Párhuzamos fordító", "frequency": "Gyakoriság: ritka", "answer": "_Megjegyzés: Bprofon be se jelölte, hogy ez kellene._<br><br>Utasitas szintu<br><br>- parhuzamos architektura vagy megfelelo forditoprogram segitsegevel<br><br>Ciklus vagy eljaras szintu: Szalak vagy folyamatok formajaban. Szal/folyamat a targykod legkisebb onalloan vegrehajthato resze. Letrehozhatja:<br><br>- Programozo<br>- Operacios rendszer<br>- Parhuzamos fordito<br><br>Program es felhasznaloi szint: Parhuzamos rendszerek, megfelelo hardver es szoftvertamogatassal"}, {"question": "76. Mi a compiler, milyen feladatai vannak?", "frequency": "Gyakoriság: ritka", "answer": "Forditoprogram ami leforditja a magas szintu programnyelvben irt programot a processzor szamara ertheto formatumra. Kulcsszerepet jatszik a parhuzamossag kihasznalasaban<br><br>1. Analizis: lexikalis (konstansok, valtozok, operatorok), szintaktikai es szemantikai elemzes<br>2. Szintetizalas: Targykod generalasa es kodomptimalizalas, amely soran a fordito fuggetlen, parhuzamosan futtathato reszeket keres"}, {"question": "77. Írja fel a párhuzamos architektúrák Flynn-féle és korszerű osztályozását!", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Táblázat (Flynn) + ágrajz (korszerű)._<br>**78. Mi a Flynn-modell, milyen osztályai vannak (csak felsorolás)?**<br>_(Gyakoriság: ritka)_<br>_Megjegyzés: Előző szokott inkább lenni._<br>**79. A Flynn-féle osztályozásban mit jelent a SIMD, mit lehet róla tudni?**<br>_(Gyakoriság: ritka)_<br>_Megjegyzés: Kettővel ezelőttivel lehet együtt._<br><br>Négy fogalom<br><br>- SI (Single instruction strem): Egyszeres utasitasfolyam, a gepnek egyetlen vezerloegysege van ami mondja mit kell tenni<br>- MI (Multiple instruction stream): Tobbszoros utasitasfolyam, a gep egyszerre tobb kulonbozo utasitasfolyamot tud egy idoben vegrehajtani<br>- SD (Single data stream): Egyszeres adatfolyam, egyszerre egy adaton vegzunk muveletet<br>- MD (Multiple data stream): Tobszoros adatfolyam, egyszerre sok fuggetlen adaton dolgozik a gep<br><br>- SISD (Single Input, Single Data): Neumann modell<br>- SIMD (Single Input, Multiple Data): Multimedias feldolgozas<br>- MISD (Multiple Input, Single Data): Elmeleti kategoria<br>- MIMD (Multiple Input, Multiple Data): Teljes parhuzamos feldolgozas<br><br>Modern osztalyozas<br><br>- Funkcionalisan parhuzamos architekturak<br>  - Utasitas szinten parhuzamos architekturak (ILP)<br>    - Futoszallag<br>    - VLIW<br>    - Szuperskalar<br>  - Szal szinten parhuzamos architekturak (SMT)<br>  - Folyamat szinten parhuzamos architekturak<br>    - ELosztott memoria hasznalato<br>    - Kozos memoria hasznalatu"}, {"question": "80. Milyen példákat ismer adatpárhuzamos architektúrákra? felsorolás ábra", "frequency": "Gyakoriság: ritka", "answer": "_Megjegyzés: Elvileg ezt már nem fogja tőlünk kérni, de ki tudja._<br><br>NO ANSWER"}, {"question": "81. Funkcionálisan párhuzamos architektúrák? felsorolás ábra", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Ez szokott lenni az \"Írja fel a párhuzamos architektúrák Flynn-féle és korszerű…\" kérdéssel._<br><br>- Funkcionalisan parhuzamos architekturak<br>  - Utasitas szinten parhuzamos architekturak (ILP)<br>    - Futoszallag<br>    - VLIW<br>    - Szuperskalar<br>  - Szal szinten parhuzamos architekturak (SMT)<br>  - Folyamat szinten parhuzamos architekturak<br>    - ELosztott memoria hasznalato<br>    - Kozos memoria hasznalatu"}, {"question": "82. Mik az ILP CPU-kra vonatkozó általános követelmények + Kibocsátási párhuzamosság?", "frequency": "Gyakoriság: kevésbé ritka", "answer": "_Megjegyzés: Inkább későbbi vizsgákon szokott lenni, de amúgy ez nem olyan nehéz._<br><br>Mindne olyan processzornak amely utasitas szintu parhuzamossagot alkalmaz, ket szigoru szabalynak kell megfelelnie:<br><br>1. Fuggosegek kezelese<br><br>- A processzornak figyelnie kell az utasitasok kozti fuggosegeket<br><br>2. Soros vegrehajtas konzisztenciaja<br><br>- A programnak a parhuzamos vegrehajtas mellet pontosan ugy kell viselkednei mintha a programozo altal megirt sorrendben egymas utan futottak volna le az utasitasok<br><br>Kibocsatasi parhuzamossag<br><br>- Kibocsatasi parhuzamossagnak nevezzuk, ha a CPU a dekodolo egysege egyetlen oraciklus alatt egynel tobb utasitast kepes tovabb kuldeni vegrehajtasra.<br>- A kibocsatas az a folyamat amikor a dekodolt utasitasok atkerulnek a vegrehajto egysegbe. Ha a CPU kepes parhuzamosan tobb utasitas vegrehajtasara a kibocsatasi kapacitast novelni kell."}, {"question": "83. Milyen szintű párhuzamosságokat használnak a mai processzorokban? Sorolja fel és mindegyik mellé írjon legalább egy gyakorlati példát!", "frequency": "Gyakoriság: kevésbé ritka", "answer": "_Megjegyzés: Őszintén fogalmam sincs, mi akar ez lenni, pedig már többször volt._<br><br>- Utasitas szintu parhuzamossag (ILP - Instruction Level Parallelism)<br>  - futoszalag vagy szuperskalar vegrehajtas<br>- Szal szintu parhuzamossag (TLP - Thread Level Parallelism)<br>  - Hyper-Threading (SMT) - egyetlen mag ket programszalat hajt vegre parhuzamosan<br>- Adat szintu parhuzamossag (DLP - Data Level Parallelism)<br>  - SIMD utasitasok, amikor egy utasitassal 8db 32 bites szamot adunk ossze egyszerre<br>- Folyamat/Mag szintu parhuzamossag (Multi-Core)<br>  - Tobmagos processzorok"}, {"question": "84. Milyen adatfüggőségeket ismer?", "frequency": "Gyakoriság: kevésbé ritka", "answer": "- Valos adatfuggoseg (RAW - Read After Write)<br>  - muveleti adatfuggoseg<br>  - lehivasi adatfuggoseg<br>- Al adatfuggoseg<br>  - WAR (Write After Read)<br>  - WAW (Write After Write)<br>- Ciklusbeli adatfuggoseg"}, {"question": "85. Sorolja fel a függőségek 3 fő csoportját és ismertesse a RAW függőséget (probléma felvetés, kezelés)!", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Itt beszélni kell a műveleti adatfüggőségről és a lehívási adatfüggőségről is._<br><br>Muveleti adatfuggoseg<br><br>Problema: Az I2 utasitas olvasni akar egy adatot amit az I1 meg nem irt vissza<br>Pelda: Ket szamot ossze akarunk szorozni majd az eredmenyeket ossze akarjuk adni.<br><br>Kezelese:<br><br>1. NOP (No Operand) -> varakozo ciklusok beiktatasa => Lassitja a vegrehajtast es mas is csuszik<br>2. Operandus elorehozas (Forwarding) -> Extra hardverrel az eredmenyt az ALU vegerol azonnal visszavezetik, megsporolva a varakozast<br><br>Lehivasi adatfuggoseg<br>Az operandusokat vegrehajtas elott az adatcache/operativ tarbol a regiszterekbe kell tolteni<br><br>Problema: Ha az adat nincs a regiszterben a betoltese idoigenyes ami varakozasra kenyszeriti az ALU-t<br>Kezeles: Betoltesi operandus elore hozasa: extra hardverrel az adatot a regiszter mellet kozvetlenul az ALU bemenetere is tovabbitjak<br>Kovetkezmeny: Legalabb 1 oraciklus nyereseg a vegrehajtasi idoben"}, {"question": "86. Ismertesse a WAR és WAW ál-adatfüggőségeket! (probléma felvetés, kezelés)", "frequency": "Gyakoriság: gyakori", "answer": "WAR (Write After Read)<br><br>Az iras hamarabb tortenne meg mint az elozo utasitas olvasasa<br><br>I1 -> MUL r3 r2 r1 = r1 es r2 erteket szorozzuk es beleirjuk r3-ba<br>I2 -> ADD r2 r4 r5 = r2be irjuk az r4 es r5 osszeadas eredmenyet<br><br>Elorodulhat, hogy az I2 ADD utasitas eredmenye hamarabb irja felul az r2 eredmenyet, mint a megelozo utasitas operandusainak beolvasasa.<br><br>Megoldas (regiszter atnevezese):<br>I1 MUL r3 r2 r1<br>I2 ADD r23 r4 r5<br><br>=> Az r23 -> r2 hozzarendelest nyilvan kell tartani, majd amikor a MUL utasitas vegzett, vissza kell irni r23 tartalmat r2-be<br><br>WAW (Write After Write)<br><br>Ket iras korul a kesobbi logikai utasitas (pl: ADD) hamarabb irna felul a regisztert mint a korabbi (pl: MUL)<br><br>I1 MUL r3 r2 r1<br>I2 ADD r3 r4 r5<br><br>Elofordulhat, hogy az I2 ADD utasitas elobb fut le mint a az I1 MUL, igy az I2 utasitas felulirja I1 eredmenyet -> Serul a szekvencialis konzisztencia<br><br>Megoldas: regiszter atnevezes<br><br>Atnevezesi regiszterek tulajdonsagai:<br><br>- uj onallo regiszter<br>- sajat cimtartomannyal rendelkezik<br>- programozo szamara transzparens<br>- extra hardvernek szamit<br><br>Ebbol adodik hogy ket fele regiszterkeszletet kulonboztetunk meg<br><br>1.  Architekturalis regiszterkeszlet<br>2.  Atnevezesi regiszterkeszlet"}, {"question": "87. Ismertesse a vezérlés függőséget (probléma felvetés, kezelés)!", "frequency": "Gyakoriság: gyakori", "answer": "- Feltetel nelkuli elagazas<br>  - Problema: Az ugras parancs keson allitja be a PC-t, addigra mag a futoszalag vegrehajtas miatt a kovetkezo parancs lehivasra kerult vagy akar le is futott -> hibas mukodes<br>  - Kezeles:<br>    - Ugrasi buborek: A JMP utasitas moge egy vagy tobb NOP utasitas kerul be, ezzel lassitva a futoszallagot, mig elo nem all az ugrasi cim => csokken a teljesitmeny<br>    - Utasitasok atrendezese: optimalizalo compiler segitsegevel<br>- Felteteles elagazas<br>  - kezelese: ma mar csak dinamikusan a vegrehajtas soran tortenhet, hiszen a feltetel teljesulesetol vagy nem teljesulesetol fugg, hogy ugras vagy soros folytatas kovetkezik-e"}, {"question": "88. Mi az az erőforrás függőség?", "frequency": "Gyakoriság: kihalt", "answer": "_Megjegyzés: Ezt nem fogja kérni tőlünk._<br><br>NO ANSWER"}, {"question": "89. Párhuzamos végrehajtás esetén milyen esetekben sérülhet a szekvenciális konzisztencia, és hogyan lehet ezeket kezelni?", "frequency": "Gyakoriság: gyakori", "answer": "- Utasitas feldolgozas soros konzisztenciaja (WAR/WAW)<br><br>  - Az egyik utasitas gyorsabban tud lefutni es ezzel felulirhatja egy elotte levo meg le nem futott utasitas regiszteret es ezzel felboritja a rendszer egyensulyat. Ennek a megoldasa, ha neha atnevezunk regisztereket, majd kesobb visszairjuk az adatokat amikor a lassabb elso utasitas is lefutott, valamint hardveres biztositas (pl, belso kovetes, kulon allapotjelzok), hogy a felteteles utasitas csak a kozvetlen elozo utasitas eredmenyet lassa<br><br>- Kivetelkezeles<br>  - Ha az egyik utasitasnal exception lepett fel de mar 3 utasitast is kiszamoltunk elore, akkor biztositani kell, hogy a szamitogep allapota a hiba pillanataban pontosan olyan legyen, mintha szekvencialisan futottunk volna."}, {"question": "90. Mit tud a kivételkezelés soros konzisztenciájáról?", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Pontatlan (gyenge konzisztencia) és pontos (erős konzisztencia) részét is tudni kell, ezek szoktak külön kérdések is lenni._<br><br>A megszakitasokat az utasitasok eredeti programsorrendjeben kell kezelni, akkor is ha a vegrehajtas parhuzamos.<br><br>- Pontatlan kivetelkezeles (gyenge konzisztencia)<br><br>  - A CPU azonnal fogadja a megszakitast, fuggetlenul attol, hogy az elozo utasitasok befejezodtek-e<br><br>  ```<br>  I1 MUL r3 r2 r1<br>  I2 ADD r5 r6 r7 -> tulcsordul es ker egy megszakitast<br>  I3 JZ cimke     -> ha az eredmeny 0, akkor ugras<br>  ```<br><br>  - Ha a gyorsabb utasitas hibaja miatt a CPU azonnal menti a kontextust, nem tudhato, hogy a logikailag korabbi, lassabb muvelet befejezodott-e -> ez definialatlan regiszterallapotot es sulyos mukodesi hibakat okoz<br><br>- Pontos kivetelkezeles<br>  - Megszakitas csak akkor fogadhato el, ha minden korabbi utasitas<br>    - befejezodott<br>    - vagy szinten megszakitast ker<br>  - Eredmeny: A mentett allapot mindig egy valos, szekvencialis programsorrendi allapot<br>  - Megvalositas<br>    - atrendezo puffer (ROB - reorder buffer)<br>    - cimkezes: utasitasok sorszamozasa, csak akkor fogadjuk el, ha egyetlen megelozo sorszamu sem kert"}, {"question": "91. Sorolja fel az ideális futószalagos feldolgozás előfeltételeit 2 fokozat esetén!", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Gyakori elővizsga/vizsga kérdés._<br><br>- 2 db egymastol teljesen fuggetlen vegrehajto egyseggel rendelkezik<br>- Egyik fokozat kimenete a masik fokozat bemenete kell legyen<br>- Mindket fokozat vegrehajtasi ideje azonos<br>- Orajelre szinkronizaltan 1 oraciklus alatt elvegzik a feladatukat<br>  T: szekvencialis vegrehajtasi ido<br>  t: futoszallagos vegrehajtasi ido<br>  t = T/2<br>  Fuggosegek kezelese:<br>  - Operandus elorehozas<br>  - Ujrafeldolgozas"}, {"question": "92. Sorolja fel a RISC CPU-k tanult jellemzőit!", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Előny, hátrány is szokott lenni._<br><br>Reduced Instruction Set Computing<br><br>- Utasitasok: Keves (50-150) -> egyszeru cimzesi modok, azonos hosszusagu utasitasok pl.: 64/128 bit<br>- Muveletvegzes: Kizarolag regisztereken vegez muveletet; memoria es cache eleres csak a LOAD/STORE utasitassal erheto el<br>- Felepites: Sok regiszter, huzalozodd dekodolas (hardveres dekodolas)<br>- Vegrehajtas: 3 operandusos, cel az 1 oraciklusos futas<br>- Szoftver: Bonyolultabb compiler<br><br>- Elonyok: alacsonyabb fogyasztas, gyorsabb utasitas szintu vegrehajtas<br>- Hatranyok: bonyolultabb feladatokat instrukcio szekvenciakkal kell megoldani, kisebb kompatibilitas, kisebb teljesitmeny ugyan azon a frekvencian (x86-64-hez kepest)"}, {"question": "93. Sorolja fel a CISC CPU-k tanult jellemzőit!", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Előny, hátrány is szokott lenni._<br><br>Complex Instruction Set Computing<br><br>- Utasitasok<br>  - nagy szamu utasitaskeszlet (tobb szaz)<br>  - valtozo hosszusagu, akar osszetett utasitasok -> dekodolonak nem csak dekodolnia kell az utasitast, hanem azonositani a veget, plusz hardvert es idot igenyel<br>  - egy utasitas tobb elemi muveletet is vegre tud hajtani<br>- Muveletvegzes: kozvetlen memoriaeleres lehetseger (2. operandus lehet memoria/cache)<br>- Felepites: Nagy belso mikroprogramtar, kevesebb regiszter<br>- Vegrehajtas: 2 operandusos - elso operandus nem lehet memoria vagy cache cim, utasitasok feldolgozasa tobb ciklusido lehet -> bonyolultabb feldolgozas<br>- Futoszalag: Altalaban +2 fokozat, sebessegkulonbseg eseten Interlock varakoztatas<br>- Szoftver: Egyszerubb compiler es gepi kodu programozas<br>- Extrak: Regi programokkal kompatibilis, HyperThreading es virtualizacio tamogatasa<br><br>- Elonyok: egyszerubb compilerek, szeles termekskala, kompatibilitas, nagy nyers teljesitmeny<br>- Hatranyok: komplex hardver, lassabb dekodolas, magasabb energiafogyasztas"}, {"question": "94. Miért hosszabb a CISC futószalag a RISC-nél?", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Előző két kérdések valamelyikével szokott együtt lenni, külön általában nincsen._<br><br>A CISC pipelineba pluszba kell:<br><br>- AG - cimszamitas<br>- DC1-2 - Data cache"}, {"question": "95. Milyen következményekei lettek a futószalagos architektúráknak? Milyen új problémák jelentkeztek (problémák okai és kezelésük 1-1 mondatban)?", "frequency": "Gyakoriság: ritka", "answer": "_Megjegyzés: Későbbi vizsgákon szokott lenni._<br><br>- Adatfuggosegek (RAW)<br>  - ok: egy utasitasnak szuksege van az elozo eredmenyere ami meg nem keszult el<br>  - kezeles: varakoztatas, vagy operandus elorehozas<br>- Vezerlesfuggoseg<br>  - ok: ugro utasitasoknal nem tudjuk mi a kovetkezo utasitas, mig a feltetel ki nem ertekelodik<br>  - kezeles: elagazas becsles vagy futoszalag uritese<br>- Eroforras konfliktus<br>  - ok: ket utasitas egyszerre akarja hasznalni ugyanazt a hardvert<br>  - kezeles: tobbportos memoria / harvard architektura"}, {"question": "96. Milyen közös jellemzői vannak az I. és II. generációs szuperskalár architektúráknak?", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Gyakori elővizsga/vizsga kérdés._<br><br>- Parhuzamos kibocsatas: dekodolo egysegbol egy oraciklusban tobb utasitas kibocsatas<br>  - 1.gen: 2-3 utasitas/ciklus<br>  - 2.gen: 4-6 utasitas/ciklus<br>- Idobeli + terbeli parhuzamossag: tobb futoszalag parhuzamosan<br>- Maguk kuzdenek meg fuggosegekkel: dinamikusan, extra hardver segitsegevel<br>- Kompatibilitas: regi programok is futtathatok maradnak"}, {"question": "97. Ismertesse a Harvard architektúrát!", "frequency": "Gyakoriság: ritka", "answer": "_Megjegyzés: Elvileg rajzot is kérhet ide._<br><br>- Utasitas es adat kulon uton mozog -> parhuzamos eleres<br>- Kulon adatutaok, novekszik a teljesitmeny<br><br>Szuperskalar CPU-kban:<br><br>- L1 cache: Harvard: utasitas + adat kulon tarolodik<br>- L2, L3 cache: Neumann: utasitas + adat kozosen tarolodnak<br>- Modositott Harvard architektura<br>  - program adatkent is kezelheto<br>  - Mai CPU-k Harvard + Neumann egyutt<br><br>Vezerlesi vazlat<br><br>- Vezerloegyseg (CONTROLL): lehivja az utasitast az Instruction Cachebol (INSTR adatut)<br>  - Ez alapjan jelet kuld a Data Cache-nek, hogy az ALU-ba milyen cim keruljon<br>  - Kozben az Instruction Cache fele is kuld jelet: kovetkezo utasitas + aktualis adat egyszerre erkezik meg<br>- ALU: IN es OUT adatutakon kommunikalhat a periferiakkal<br>  - vezerloegyseg iranyitja az ALU-t, STATUS adatuton visszacsatolat biztosit fele<br><br>Minden muvelet orajelre szinkronizalt<br><br>- Elonyei:<br>  - kepes parhuzamosan adatot es utasitast olvasni vagy irni cache nelkul<br>  - Az adat es utasitas tarolok kulonallo cimtartomannyal rendelkeznek"}, {"question": "98. Milyen fajtái vannak a szűk keresztmetszeteknek?", "frequency": "Gyakoriság: ritka", "answer": "- Kibocsatas: kozvetlen kibocsatas miatt a gyakorlati teljesitmeny (kb 1 utasitas / ciklus) messze elmaradt az elmeleti lehetosegektol<br>- Memoria: a memoria lassusagot csokkentettek a cache bevezetesevel<br>- Elagazasfeldolgozas: csokkentese statikus elagazasbecslessel<br>- Blokkolo adatfuggosegek: ez volt a legnagyobb problema: az adatfuggosegek es az al-adatfuggosegek is teljesen blokkoltak a vegrehajtast, mert a rendszer meg nem tudta ezeket kezelni"}, {"question": "99. Sorolja fel a II. generációs szuperskalárok újdonságait (1-1 mondat magyarázatként mindegyikhez)!", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Gyakori elővizsga/vizsga kérdés._<br><br>- Dinamikus utasitas utemezes<br>  - A cpu nem ragad le egy hibas vagy varakozo utasitasnal, hanem atugorja azt es halad tovabb a tobbiel.<br>  - Kibocsatas: a dekodolobol a varakoztato allomasba meg sorrendbe erkeznek az utasitasok<br>  - Kikuldes: a varakoztato allomasbol a vegrehajto egysegek fele mar sorrenden kivul mennek az utasitasok amint felszabadulnak a szukseges adatok (streber modell)<br>  - Eredmeny: Megszunteti a kibocsatasi szuk keresztmetszetet es noveli az atbocsatokepesseget<br>- Regiszter atnevezes<br>  - Az al adatfuggosegek felszamolasa. A cpu minden eredeti regiszterhez egy kulon atnevezesi regisztert rendel. Tamogatja a dinamikus elagazasbecslest, ha a CPU rossz agon indult el az eredmenyek csak az atnevezesi regiszterben vannak<br>- Dinamikus elagazasbecsles<br>  - Az elagazasok kimenetet tortenet bitekben tarolja a CPU es ebbol josol a kovetkezo alkalomra.<br>  - Becsles tipusai:<br>    - 1 bites: csak az utolso elagazas alapjan dont.<br>    - 2 bites<br>      - 11 - hatarozott<br>      - 10 - gyenge<br>      - 01 - gyenge soros<br>      - 00 - hatarozott soros folytatas<br>- Kifinomult es kibovitett gyorsitotar alrendszer<br>- Sorrenden kivuli kikuldes<br>  - kibocsataskor mar nincs fuggosegvizsgalat.<br>  - Ez a puffer valasztja el a folyamat elso reszet (lehivas/dekodolas) a hatso reszetol (tenyleges vegrehajtas)<br>- RISC mag<br>- Reorder Buffer<br>  - Kor alaku puffer: A ROB egy folytonos korpufferkent mukodik ahol az utasitasok a bemeneti mutatoknal lepnek be es a vegmutatonal tavoznak<br>  - Parhuzamos kikuldes: a ket mutato kozotti teruleten varakozo utasitasok korul barmelyik fuggetlen utasitas kikuldheto vegrehajtasra, fuggetlenul az eredeti sorrendtol"}, {"question": "100. A reorder buffer (ROB) működése ÁBRÁVAL + Kiírási szabályok!", "frequency": "Gyakoriság: kevésbé ritka", "answer": "_Megjegyzés: A kiírási szabályok külön kérdés is lehet szerinte. NAGYON FONTOS TUDNI KÉSŐBBI VIZSGÁKRA! Elővizsgán szerintem nem lehet._<br><br>- Kor alaku puffer<br>  - A ROB egy folytonos korpufferkent mukodik ahol az utasitasok a bemeneti mutatoknal lepnek be es a vegmutatonal tavoznak<br>- Parhuzamos kikuldes<br>  - a ket mutato kozotti teruleten varakozo utasitasok korul barmelyik fuggetlen utasitas kikuldheto vegrehajtasra, fuggetlenul az eredeti sorrendtol<br>- Spekulativ vegrehajtas es biztonsag<br>  - Spekulativ bit: minden utasitashoz tartozik egy bit: ha erteke 1 az utasitas feltetele meg nem kerult kiertekelesre<br>  - Amig a spekulativ bit 1 az eredmeny nem irhati ki a vegleges memoriaba<br>- Feltetel kiertekelese utan<br>  - helyes irany eseten a spekulativ bit erteke 0-ra all<br>  - hibas irany eseten a ROB-bol torlesre kerul az utasitas es az atnevezesi regiszterek felszabadulnak<br>- Kiirasi szabalyok<br>  - Csak akkor irhati ki, ha minden korabbi utasitas kiirasa mar megtortent<br>  - SPekulativ allapotban levo utasitas nem irhato ki<br>  - CISC-rekonverzio utasitas tobb belso RISC muveletre bomlik, a kiiras csak akkor tortenik meg, ha az osszes hozzatartozo RISC egyseg elkeszult. Itt tortenik a rekonverzio is"}, {"question": "101. Ismertesse az utasításon belüli párhuzamosság elvét! Milyen gyakorlati megvalósításokat ismer?", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Fogalmam sincs, mi szeretne lenni a \"gyakorlati megvalósítás\". Talán felsorolni a duál műveleti, VLIW és SIMD-et és a SIMD-ről írni?_<br><br>- Dual muveleti utasitasok<br>  - Egy utasitas ket muveletet vegez (multiply-add: y = ax + b)<br>- SIMD utasitasok<br>  - Egyetlen utasitas, tobb egymastol fuggetlen operanduson hajtja vegre ugyanazt a muveletet<br>- VLIW architekturak<br>  - A forditoprogram csomagol tobb fuggetlen muveletet egyetlen hosszu utasitasszoba"}, {"question": "102. SIMD-nél fontos tudni fixpontos és lebegőpontos multimédiát, de alapjáraton a jellemzőket több vizsgán is kérte már!", "frequency": "Gyakoriság: kevésbé ritka", "answer": "_Megjegyzés: Számomra ez rejtély. Valóban szerepel a táblázatban több helyen, hogy SIMD, de nem tudom, hogy mit kért ott. Nehéz kérdésnek titulálnám._<br><br>- Logikai architektura kiterjesztese<br>  - uj multimedias utasitas keszletet alkottak<br>- Memoriaigeny<br>  - Egy utasitas akar 8 operandust is kerhet, ami drasztikusan novelte a savszekesseg igenyt<br>  - Megoldas: Az L2 cache beepult a processzorba<br>- Buszrendszer<br>  - Megjelent az AGP, majd a PCI Express a grafikai adatok gyorsabb mozgatasahoz<br>- MMX (Multimedia Extension)<br>  - fixpontos multimedias utasitasok<br>- SSE (Streaming SIMD Extension)<br>  - ami mar lebegopontos muveleteket is tamogatta<br>- Alkalmazas<br>  - Multimedias alkalmazasoknal mint video, kep es 3d jatekok eseten oriasi gyorsulast jelentett"}, {"question": "103. SIMD Logikai Architektúra + 3D Ábrázolás", "frequency": "Gyakoriság: kihalt?", "answer": "_Megjegyzés: Lehet hogy a fizikai/logikai architektúrát kérdezi, amikor SIMD-et kérdez, viszont elvileg 3D ábrázolást tőlünk már nem fog kérdezni._<br><br>Logikai architektura kibovitese<br><br>- Pakolt adattipusok: 64 bites egysegekbe tobb kisebb adatot csomagolnak<br>  - Pakolt byte (8 bit hossz x 8db = 64 bit)<br>  - Pakolt felszo (16bit hossz x 4db = 64 bit)<br>  - Pakolt szo (32 bit hossz x 2db = 64 bit)<br>  - SSE pakotl tipus - egyszeres pontossag (32 bit x 4db = 128 bit)<br>  - SSE pakotl tipus - ketszeres pontossag (64 bit x 2db = 128 bit)<br>- Bit-blokk atvitel<br>  - Az ablakokat/kepeket egyseges blokkonkent kezeli a rendszer, igy nem kell elemenkent mozgatni a hatalmas adatmennyiseget<br><br>Fizikai architektura kibovitese<br><br>- SSE (lebegopontos): 8 darab uj 128 bites regiszterek kerultek a cpu-ba<br>- Operacios rendszer tamogatasa: AZ uj regiszterek es a megvaltozott megszakitasrendszer miatt szikseg volt az OS egyutmukodesere"}, {"question": "104. Mutassa be a VLIW működési elvét!", "frequency": "Gyakoriság: kihalt", "answer": "_Megjegyzés: VLIW már nem az anyag része._<br><br>NO ANSWER"}, {"question": "105. Milyen előnyei és hátrányai vannak a VLIW-nek a szuperskalárokhoz képest?", "frequency": "Gyakoriság: kihalt", "answer": "_Megjegyzés: VLIW már nem az anyag része._<br><br>NO ANSWER<br><br>## 12. Modul: Netburst és Szálak<br><br>**106. Hogyan növelhető a frekvencia, milyen következményekkel jár? (Netburst)**<br>_(Gyakoriság: gyakori)_<br><br>- Gyartasi csikszelesseg csokkentese (180nm -> 65nm) Kisebb tranzisztorok = gyorsabb elektronaramlas = magasabb orajel<br>- Futoszalag-fokozatok roviditese<br>  - A logikai kapuk szamanak csokkentese egy fokozatun belul<br>  - Ez kenyszeruen novelte a fokozatok szamat<br>  - Tobb fokozat -> parhuzamosan vegrehajtott utasitasok szama nott -> fuggosegek szama is no -> csokkenhet a hatekonysag es egy ertek folott a teljesitmeny is"}, {"question": "107. Ismertesse a \"rapid execution engine\", a \"replay system\" és az \"execution trace cache\" tulajdonságait, előnyök, hátrányok (Netburst architektúra)!", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Gyakori elővizsga kérdés._<br><br>- Execution Trace Cache:<br>  - Az L1 cache mar dekodolt RISC utasitasokat tarol a vegrehajtas sorrendjeben, igy sporol a dekodolasi idon<br>- Execution Engine<br>  - Az egyszeru FX muveletek gyors vegrehajtasara Az orajel felfuto es lefuto elere is kepes muveletvegzesre -> vegrehajtasi ido akar fel oracuklus<br>- Replay System<br>  - RISC szeru utasitasok ismetelt vegrehajtasa<br>  - Ha egy utasitas adata meg nincs keszm nem allitja meg a futoszalagot, hanem beleteszi egy varolistaba es kesobb ujraprobalja"}, {"question": "108. Sorolja fel a Netburst architektúra újdonságait rövid magyarázatokkal!", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Ide a kell az Execution Trace Cache, Rapid Execution Engine, Replay System ÉS Hyper futószalag, Quad Data Rate Bus, Enchanced Branch Prediction._<br><br>- Execution Trace Cache:<br>  - Az L1 cache mar dekodolt RISC utasitasokat tarol a vegrehajtas sorrendjeben, igy sporol a dekodolasi idon<br>- Execution Engine<br>  - Az egyszeru FX muveletek gyors vegrehajtasara Az orajel felfuto es lefuto elere is kepes muveletvegzesre -> vegrehajtasi ido akar fel oracuklus<br>- Replay System<br>  - RISC szeru utasitasok ismetelt vegrehajtasa<br>  - Ha egy utasitas adata meg nincs keszm nem allitja meg a futoszalagot, hanem beleteszi egy varolistaba es kesobb ujraprobalja<br>- Quad Data Rate Bus<br>  - Orajelenkent 4x-es adattovabbitas (felfuto/lefuto + faziseltolas) L1 es L2 gyorsitotarak fele. Szukseges 2 orajel generator<br>- Enchanced Branch Prediction<br>  - Uj elagazasbecslo logika 94%-97%-os hatekonysagu, hogy a futoszalagot ne keljen gyakran uriteni<br>- Hyper futoszalag<br>  - A dekodolast kihelyeztek a futoszalagon kivulre, hogy ne akadalyozza a magas frekvenciat"}, {"question": "109. Ismertesse a Netburst architektúra hátrányait! + idén ahogy mondta: Fejlődési korlátok", "frequency": "Gyakoriság: kevésbé ritka", "answer": "_Megjegyzés: Úgy is szokott lenni, hogy Netburst következményei._<br><br>- Hatekonysagi korlat<br>- Disszipacios korlat (ho)<br>  - Statikus disszipacio<br>    - A szivargasi aram hoveszteseget okoz. Ahogy csokkentettek a csikszelesseget es noveltek a frekvenciat a szivargasi aram exponencialisan novekedni kezdett<br>  - Dinamikus disszipacio<br>    - A frekvencia novelese linearisan mig a feszultseg novelese negyzetesen novelo a hot -> frekvencia emeleset a feszultseg csokkentesevel probaljak ellensulyozni<br>- Parhuzamos buszok frekvencia korlatja"}, {"question": "110. Pentium 4 Legfontosabb Újítások", "frequency": "Gyakoriság: kihalt?", "answer": "_Megjegyzés: Nem hinném, hogy ezt már kérné, de ki tudja._<br><br>- CISC kivul, de belul egy gyors RISC mag<br>- Hosszu futoszallagok: tobb fuggoseg, de magasabb frekvencia<br>- Vedelem: bevezettek a Thermal Monitort ami tulmalegedesor visszavette az orajelet"}, {"question": "111. Mi az a statikus disszipáció, ismertesse, írja fel a képletét!", "frequency": "Gyakoriság: kevésbé ritka", "answer": "- Ahogy csokkentettek a csikszelesseget es noveltek a frekvenciat a szivargasi aram exponencialisan novekedni kezdett<br><br>```<br>Ds = V * Ileak<br>V = frekvencia<br>Ileak = szivargasi aram<br>```"}, {"question": "112. Sorolja fel a disszipáció típusait képlettel, és jellemezze ezeket!", "frequency": "Gyakoriság: kevésbé ritka", "answer": "- A frekvencia novelese linearisan mig a feszultseg novelese negyzetesen novelo a hot -> frekvencia emeleset a feszultseg csokkentesevel probaljak ellensulyozni<br><br>```<br>Dd = A * C * V^2 * fc<br>A = az aktiv kapuk reszaranya<br>C = a kapuk osszesitett elosztott kapacitasa<br>V = tapfeszultseg<br>fc = megfrekvencia<br>```"}, {"question": "113. Mi az a Data Valid Window? Ábrázolja és magyarázza el!", "frequency": "Gyakoriság: ?", "answer": "_Megjegyzés: Ezt inkább a párhuzamos buszok frekvencia korlátaival sorolnám fel, elvileg eddig nem nagyon kérte, de simán kérheti._<br><br>- A digitalis jelek a valosagban nem tokeletesek. A jel felfutasahoz es lefutasahoz ido kell, raadasul a zaj es kesleltetesi kulonbsegek miatt a jel remeg<br>  - A data valid window az az ablak az orajel ciklus kozepen ahol a jel mar megnyugodott"}, {"question": "114. Mi a \"Jitter\", az LVDS, a DVFS és a \"Skew\"?", "frequency": "Gyakoriság: ?", "answer": "_Megjegyzés: Itt egyedül a DVFS-t vettük, illetve a Jitter/Skew az szintén a párhuzamos buszok frekvencia korlátaira jellemző (buszrendszerek témakör)._<br><Hely a válasznak>"}, {"question": "115. Sorolja fel a thread (szál) tulajdonságait, miért rosszabb mint az ILP?", "frequency": "Gyakoriság: kevésbé ritka", "answer": "Thread: A program legkiseb onalloan vegrehajthato resze -> parhuzamosan futtathato<br><br>- implicit parhuzamossag<br>  - A programozo hagyomanyos soros kodot ir. A parhuzamositast a hardver es a compiler vegzi<br>- explicit parhuzamossag<br>  - A programozo tudatosan parhuzamos szerkezetu kodot ir, kulon meghatarozva a szalakat es azok egyuttmukodeset"}, {"question": "116. Szál definíció", "frequency": "Gyakoriság: kevésbé ritka", "answer": "_Megjegyzés: Más kérdésekkel szokott együtt lenni._<br><br>Thread: A program legkiseb onalloan vegrehajthato resze -> parhuzamosan futtathato"}, {"question": "117. Szálak származtatása", "frequency": "Gyakoriság: ?", "answer": "_Megjegyzés: Fogalmam sincs, hogy ezt mikor/hol kérte._<br><br>- implicit parhuzamossag<br>  - A programozo hagyomanyos soros kodot ir. A parhuzamositast a hardver es a compiler vegzi<br>- explicit parhuzamossag<br>  - A programozo tudatosan parhuzamos szerkezetu kodot ir, kulon meghatarozva a szalakat es azok"}, {"question": "118. SMP SMT (Többszálú CPU), SMT Megvalósítási célok", "frequency": "Gyakoriság: ?", "answer": "_Megjegyzés: Fogalmam sincs, hogy ezt mikor/hol kérte._<br><br>Tobbszalusag csoportositasa<br><br>- Szoftveres: Tobbszalu alkalmazasok, vagy OS futtatasa egyszali CPU-n<br>- Hardveres: A CPU maga tamogatja tobb szal kezeleset<br>- SMP - Symmetric multiprocessing: tobb kulon mag egy lapkan<br>- SMT - Simultaneous multithreading: Egy mag futtat egyszerre tobb szalat (HyperThreading)"}, {"question": "119. Röviden ismertesse a szál szintű párhuzamosság tanult típusait (3 db)!", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Gyakori elővizsga/vizsga kérdés._<br><br>- Finoman szemcsézett<br>  - Működési elv: Órajelenként vált a szálak között<br>  - Előny: Nincs váltási késleltetés; az egyik szál elakadása nem állítja meg a CPU-t<br>  - Hátrány: Az egyedu szálak végrehajtási ideje megnő, mivel ritkán kapnak vezérlést<br>- Durván szemcsézett<br>  - Működési elv: Akkor vált szálat, ha az aktuális elakad<br>  - Előny: Egyetlen szál képes a teljes CPU eroforrast maximalis sebesseggel kihasznalni<br>  - Hátrány: A valtas felusmerese es a kontextus csere 1-2 ciklus vesztesggel jar<br>- SMT<br>  - Működési elv: Egyetlen orajelen belul tobb kulonbozo szal utasitasait futtatja egyszerre<br>  - Előny: Kitolti a fuggosegek miatti uresjaratokat a vegrehajto egysegekben<br>  - Hátrány: -"}, {"question": "120. Miért \"éri meg\" a szál szintű párhuzamosságot használni?", "frequency": "Gyakoriság: gyakori", "answer": "_Megjegyzés: Gyakori elővizsga/vizsga kérdés._<br><br>Kitolti a fuggosegek miatti uresjaratokat a vegrehajto egysegekben. Mivel az egymagos CPU-k komplexitasanak novelese mar nem hozott aranyos teljesitmenyjavulast a fejlesztes az utasitasszintu parhuzamossagrol a szalszintuparhuzamossag fele fordult."}, {"question": "121. Ismertesse az Intel Hyper Threading technológiát!", "frequency": "Gyakoriság: kevésbé ritka", "answer": "_Megjegyzés: Inkább későbbi vizsgákon szokott lenni._<br><br>Egy két szálas SMT megoldás amely először a Pentium 4-el jelent meg.<br><br>Lényege:<br><br>- Egyetlen fizikai mag; az operacios rendszer fele ket logikai CPU-kent jelenik meg. A processzor ket kulonbozo szal utasitasait kezeli es kuldi vegrehajtasra (sorrenden kivul)<br>- A CPU-ban ekkor egyszerre ket achitekturalis allapot van jelen<br>  - ket kulon PC, regiszterkeszlet, de a vegrehajto egysegeken osztoznak<br><br>Uzemmodok:<br><br>- ST (Single Task)<br>  - egy szal vegrehajtas tortenik<br>  - A szal az osszes vegrehajtp eroforrast megkapja<br>  - Ket lehetseges allapot ST0 vagy ST1 attol fugg melyik logikai CPU aktiv<br>- MT (Multi task)<br>  - Tobb szal vegrehajtasa tortenik parhuzamosan<br>  - A szalak osztoznak a vegrehajto egysegeken<br><br>Mukodes<br><br>- A CPU alapertelmeuetten MT modban indul<br>- Ha az egyik szal megszakad ST modba valt<br>- Fuggoseg megszunesekor visszater MT modba<br>- Uzemmod valtas HALT utasitassal tortenik<br>  - Megszakitja a CPU futast<br>  - Energiatakarekot allapotba helyezi<br>- HALT utan ST0 vagy ST1 allapotba kerul<br>- HALT utasitast kizarolag az OS vagy mas alacsony szintu szoftver adhatja ki."}];