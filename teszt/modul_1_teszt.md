# 1. Modul Teszt: Architektúrák

Válaszolj az alábbi kérdésekre a tananyag alapján. Minden kérdés 10 pontot ér.

1. **Hasonlítsa össze a Neumann-modellt és az Adatfolyam-modellt!** Térjen ki a végrehajtás vezérlésére (mi hajtja a számítást), az adatok tárolására és az utasítások sorrendiségére!
   A neumann modell egy szekvenciális végrehajtású modell, ami azt jelenti, hogy van egy megadott utasítás készlet és ezen végigmegy egy program counter ami minden utasítást egyesével végrehajt. Az utasítások változókat manipulálnak adatokkal vagy műveletekkel, így figyelni kell a sorrendre, mert előzm,ényérzékeny. Cserébe egyszerűbb megvalósítani. Az adatfolyam modell ezzel szemben, stréber modellnek számít, hisz itt nincs program counter, itt amint megjelennek az adatok egyből nekilát a műveletek végrehajtásának. Egy gráfként kell elképzelni, az éleken folynak az adatok a csomópontokban pedig történnek a műveletek. Ez azért jó mert nagyon könnyű párhuzamosítani, így gyorsabb végrehajtást tesz lehetővé. Ezzel szemben a Neumann modell nehezen és komplikáltan párhuzamosítható. A neumann modell az adatokat a változókban tárolja, míg az adatfolyam modell adathalmazokban.

2. **Definiálja a fizikai és a logikai architektúra fogalmát!** Magyarázza el, mit vizsgálunk "számítógép szinten" és "processzor szinten" mindkét esetben!
   A fizikai architektúrának két része van van amikor számítógép szinten nézzuk ahol nem tudjuk egyes alkatrészek mit csinálnak, csak azt, hogy milyen alkatrészek vannak benne: CPU, Buszrendszer, Memória. A másik amikor processzori szinten nézzük, itt nem tudjuk mi megy végbe az alkatrészeknél csak azt, hogy milyen alkatrészekből áll: alu, vezérlő, io rendszer, megszakítások. Illetve van a logikai architektúra. Itt nem tudjuk milyen alkatrészek vannak egy sz.gépben, csak azt tudjuk hogy egy feladat megoldására milyen eredményt szeretnénk látni és ezt az op rendszer felugyeli. Illetve van amikor magára a processzorra tekintunk feketedobozkent igy nem tudjuk mi van benne csak az tudjuk hogy egy utasítasra mit ad vissza es ebbol tud epitkezni a felhasznalo.

3. **Fejtse ki a Virtuális Memória és a Fizikai Memória közötti különbséget és kapcsolatot!** Mi a szerepe az MMU-nak ebben a folyamatban?
   A virtualis memoria egy olyan memoria ami a processzortol tavol helyekzedik el es ezt csak a programozo latja. Amikor feladatokat lat el a cpu akkor egy transzparens folyamat az adatokat hasznalat kozben a virtualis es fizikai kozott mozgatja ezt ugy hivjak hogy memory management unit. A virtualis memoria lenyegesen lassabb a fizikainal mert itt a buszrendszert is hasznalatba kell venni. A fizikia memoria ellenben nagyon gyors mert a processzor lapkajan van igy kozvetlenul el tudja erni es adatokat irni vagy olvasni belole.

4. **Ismertesse a regiszterek típusait és funkcióit!** Térjen ki az általános célú, a verem (stack) és a többszörös (átfedő) regiszterkészletekre!
   A regisztereknek tobb alfaja van vannak a sima egyszeru regiszterek amik tulajdonkeppen akkumulatorok es ugy tarolnak adatot. Vannak az univerzalis regiszterek amik barmilyen adatot kepesek tarolni foleg olyat raknak ebbe amihez gyakran hozza kell fernie egy folyamat alatt a cpunak vannak a stack vagy verem tipusu regiszterek amibe az adatok mennek be de mindig csak a legfelsohoz tudnak hozzaferni, igy nem kell management hozza viszont az adatokat csak megfelelo sorrendben lehet kihalaszni belole. illetve vannak a tobszorosen atfedo regiszterek, ahol egy regiszternek a bemenete egy helyen van az elozo regiszter kimenetevel vagyis egy regiszter terben vannak, igy nem kell idot es energiat pazarolni a kontextus valtasra, mert egymas mellol mar lehet folytatni az olvasast amig a hatterben betoltodik a kovetkezo regiszter. Vannak olyanok amik fizikalisan vannak egymashoz kepest eltolva megvalositva ebbol altalaban max 8-t szoktak alkalmazni mert ha annal tobb kell akkor valamit rosszul csinal az ember es az meg relative olcson megoldhato, illetve van olyan amikor van egy nagy regiszter es abban egy algoritmussal cimezunk meg regiszter reszleteket de itt is atfedessel hogy a kovetkezo regiszter tudjon hivatkozni. Ez azert jo mert eleg egy nagy regiszter a tobbit megoldjuk szoftveresen.

5. **Mutassa be az utasítástípusokat az operandusok száma szerint (3, 2, 1, 0 címes)!** Milyen előnyei és hátrányai vannak az egyes típusoknak (pl. utasításhossz, sebesség)?
   Vannak a 3 cimes utasitasok amiben meg van adva a ket ertek amivel szamolni kell es a harmadik pedig arar mutat ahova kell az erteket elhelyezni. Ezek a regebbi cisc archiutekturaju gepknel voltak hasznalva, emelle nagyon sok utasitas tartsul tobb szaz es ezzel a ketto komboval mar barmit meg lehetett valositani. Aztan jott a risc architektura ami mar csak ket operandust hasznalt igy a masodik ertekbe kellett a vegeredmenyt is beirni ez gyorsabb volt mert nem kellett meg egy regiszterkeszletet betolteni es menedzselni valamint olcsobb is volt pont emiatt. A 3 iperandusosnal ugye kellett egy 3. regiszter is mint vegeredmeny igy az komplexebb e slassabb volt. Ehhez a risc architekturahoz es a 2 operandusos utasitasokhoz mar kevesebb utasitas is tarsult itt kb max 150 utasitas volt es azok egyszerubbek nem komplexek mint az elodjenel. Vannak az egy operandusos utasitasok amiknel a bemenet es a kimenet is ugyan az regiszter volt igy olcso volt gyorsabb de elegge limitaltak voltak a lehetosegek. Illetve vannak a 0 cimes utasitasok azok az egyszerubbek pl clear start stb amihez nem kell ertek csak egy utasitas ami mar tudja mit csinal. Az 1 utasitasoshoz pl a jump az tokeletes pelda mert itt csak megadjuk hova ugorjon.
